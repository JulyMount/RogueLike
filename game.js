const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const gameContainer = document.getElementById('game-container');

// HUD Elements
const healthDisplay = document.getElementById('health');
const xpTextDisplay = document.getElementById('xp-text');
const powerUpDisplay = document.getElementById('power-up');
const bossHud = document.getElementById('boss-hud');
const bossHealthBar = document.getElementById('boss-health-bar');
const bossPhaseIcons = document.getElementById('boss-phase-icons');
const bossNameSpan = document.getElementById('boss-name-span');

// Screen Elements
const startScreen = document.getElementById('start-screen');
const gameOverScreen = document.getElementById('game-over-screen');
const startButton = document.getElementById('start-button');
const restartButton = document.getElementById('restart-button');
const finalScoreDisplay = document.getElementById('final-score');
const highScoreDisplay = document.getElementById('high-score-display');
const finalHighScoreDisplay = document.getElementById('final-high-score-display');

let gameLoopId;
let gameRunning = false;

// Game constants
const GRAVITY = 0.6;
const JUMP_FORCE = -14;
const PLAYER_SPEED = 5;
const STOMP_BOUNCE = -7;
const TILE_SIZE = 50;
const COYOTE_TIME_FRAMES = 8;
const JUMP_BUFFER_FRAMES = 8;
const MAX_FALL_SPEED = 18;

// --- SISTEMA DE PROGRESS√ÉO DE CHEFES ---
const bossProgression = [
    { name: 'Gorila Furioso', scoreRequirement: 20, emoji: 'ü¶ç' },
    { name: 'Rob√¥ Sentinela', scoreRequirement: 50, emoji: 'ü§ñ' }
];
let bossesDefeated = 0;

// --- SISTEMA DE SAVE ---
let savedData = {};

// Vari√°veis de Batalha
const CHUNK_SIZE = 15;
let isBossEligible;
let roomsGeneratedThisChunk;
let canEnterDoor = false;
let isBossFightActive = false;
let transitionState = 'none';
let transitionAlpha = 0;
let transitionColor = 'black';

let player, keys, camera, platforms, items, enemies, projectiles, particles, hudParticles, gravestones, decorations, boss;
let circularShockwaves, visualEffects;
let generationCursor;
let xpShakeTimer = 0;

const defaultBgColor = { r: 13, g: 26, b: 46 };
let currentBgColor = { ...defaultBgColor };
let targetBgColor = { ...defaultBgColor };
let bgFlashTimer = 0;

const roomTemplates = { 'start': {width: 4 * TILE_SIZE, platforms: [{ x: 0, y: 0, width: 4 * TILE_SIZE }], exit: { x: 4 * TILE_SIZE, y: 0 }}, 'corridor': {width: 8 * TILE_SIZE, platforms: [{ x: 0, y: 0, width: 8 * TILE_SIZE }], exit: { x: 8 * TILE_SIZE, y: 0 }}, 'gap': {width: 8 * TILE_SIZE, platforms: [{ x: 0, y: 0, width: 3 * TILE_SIZE }, { x: 5 * TILE_SIZE, y: 0, width: 3 * TILE_SIZE }], exit: { x: 8 * TILE_SIZE, y: 0 }}, 'multi_level': {width: 12 * TILE_SIZE, platforms: [{ x: 0, y: 0, width: 12 * TILE_SIZE }, { x: 2 * TILE_SIZE, y: -4 * TILE_SIZE, width: 8 * TILE_SIZE }], exit: { x: 12 * TILE_SIZE, y: 0 }}, 'climb': {width: 10 * TILE_SIZE, platforms: [{ x: 0, y: 0, width: 3 * TILE_SIZE }, { x: 4 * TILE_SIZE, y: -2.5 * TILE_SIZE, width: 2 * TILE_SIZE }, { x: 7 * TILE_SIZE, y: -5 * TILE_SIZE, width: 3 * TILE_SIZE }], exit: { x: 10 * TILE_SIZE, y: -5 * TILE_SIZE }}, 'shaft': {width: 10 * TILE_SIZE, platforms: [{ x: 0, y: 0, width: 3 * TILE_SIZE }, { x: 1 * TILE_SIZE, y: 2 * TILE_SIZE, width: 2 * TILE_SIZE }, { x: 7 * TILE_SIZE, y: 4 * TILE_SIZE, width: 2 * TILE_SIZE }, { x: 1 * TILE_SIZE, y: 6 * TILE_SIZE, width: 2 * TILE_SIZE }, { x: 0, y: 8 * TILE_SIZE, width: 10 * TILE_SIZE }], exit: { x: 10 * TILE_SIZE, y: 8 * TILE_SIZE }}, 'staircase_down': {width: 12 * TILE_SIZE, platforms: [{ x: 0, y: 0, width: 3 * TILE_SIZE }, { x: 3 * TILE_SIZE, y: 1.5 * TILE_SIZE, width: 3 * TILE_SIZE }, { x: 6 * TILE_SIZE, y: 3 * TILE_SIZE, width: 3 * TILE_SIZE }, { x: 9 * TILE_SIZE, y: 4.5 * TILE_SIZE, width: 3 * TILE_SIZE }], exit: { x: 12 * TILE_SIZE, y: 4.5 * TILE_SIZE }}, 'pillar_room': {width: 15 * TILE_SIZE, platforms: [{ x: 0, y: 0, width: 15 * TILE_SIZE }, { x: 3 * TILE_SIZE, y: -3 * TILE_SIZE, width: 1.5 * TILE_SIZE }, { x: 8 * TILE_SIZE, y: -4 * TILE_SIZE, width: 1.5 * TILE_SIZE }, { x: 12 * TILE_SIZE, y: -2 * TILE_SIZE, width: 1.5 * TILE_SIZE }], exit: { x: 15 * TILE_SIZE, y: 0 }}, 'chain_jump': {width: 14 * TILE_SIZE, platforms: [{ x: 0, y: 0, width: 3 * TILE_SIZE }, { x: 4.5 * TILE_SIZE, y: -0.5 * TILE_SIZE, width: 1 * TILE_SIZE }, { x: 7 * TILE_SIZE, y: 0 * TILE_SIZE, width: 1 * TILE_SIZE }, { x: 9.5 * TILE_SIZE, y: -0.5 * TILE_SIZE, width: 1 * TILE_SIZE }, { x: 11 * TILE_SIZE, y: 0, width: 3 * TILE_SIZE }], exit: { x: 14 * TILE_SIZE, y: 0 }}, 'boss_arena': {width: 18 * TILE_SIZE, platforms: [{ x: 0, y: 0, width: 18 * TILE_SIZE }], decorations: [{ emoji: 'üö™', x: (18 * TILE_SIZE / 2) - 25, y: -50 }], exit: { x: 18 * TILE_SIZE, y: 0 }} };

function saveGame() {
    try {
        localStorage.setItem('minhaAventuraSave', JSON.stringify(savedData));
    } catch (e) {
        console.error("N√£o foi poss√≠vel salvar o jogo:", e);
    }
}

function loadGame() {
    try {
        const data = localStorage.getItem('minhaAventuraSave');
        if (data) {
            savedData = JSON.parse(data);
        } else {
            savedData = { highScore: 0 };
        }
    } catch (e) {
        console.error("N√£o foi poss√≠vel carregar o save:", e);
        savedData = { highScore: 0 };
    }
    if (typeof savedData.highScore !== 'number') {
        savedData.highScore = 0;
    }
}

function resizeCanvas() { canvas.width = gameContainer.clientWidth; canvas.height = gameContainer.clientHeight; }

function init() {
    resizeCanvas();
    player = { x: 150, y: canvas.height - 200, width: 50, height: 50, vx: 0, vy: 0, speed: PLAYER_SPEED, onGround: false, facingRight: true, health: 5, maxHealth: 5, xp: 0, powerUp: null, powerUpTimer: 0, isImmune: false, canDoubleJump: false, doubleJumpUsed: false, speedMultiplier: 1, isDying: false, rotation: 0, coyoteTimeCounter: 0, jumpBufferCounter: 0 };
    keys = { right: false, left: false, jump: false };
    camera = { x: player.x, y: player.y, zoom: 1.0, targetZoom: 1.0, shakeDuration: 0, shakeMagnitude: 0, zoomOverrideTimer: 0 };
    platforms = []; items = []; enemies = []; projectiles = []; particles = []; hudParticles = []; gravestones = []; decorations = []; circularShockwaves = []; visualEffects = [];
    boss = null;
    bossesDefeated = 0;
    isBossEligible = false;
    roomsGeneratedThisChunk = 0;
    isBossFightActive = false;
    canEnterDoor = false;
    transitionState = 'none';
    transitionAlpha = 0;
    transitionColor = 'black';
    generationCursor = { x: 50, y: canvas.height - 100 };
    stampRoom('start');
    for(let i = 0; i < 4; i++) { stampRoom(); }

    loadGame();
    highScoreDisplay.textContent = `High Score: ${savedData.highScore}`;
}

function jumpToBoss(bossIndex) { if (!gameRunning) { init(); bossesDefeated = bossIndex; isBossEligible = true; startScreen.style.display = 'none'; gameRunning = true; startBossTransition(); gameLoop(); } }
function updateBossEligibility() { if (bossesDefeated < bossProgression.length) { const nextBoss = bossProgression[bossesDefeated]; if (!isBossEligible && player.xp >= nextBoss.scoreRequirement) { isBossEligible = true; } } }
function stampRoom(roomName, canSpawnEntities = true) { let chosenRoomName; roomsGeneratedThisChunk++; if (isBossEligible && roomsGeneratedThisChunk === 1) { chosenRoomName = 'boss_arena'; } else { const templateNames = Object.keys(roomTemplates).filter(name => name !== 'start' && name !== 'boss_arena'); chosenRoomName = roomName || templateNames[Math.floor(Math.random() * templateNames.length)]; } if (roomsGeneratedThisChunk >= CHUNK_SIZE) { roomsGeneratedThisChunk = 0; } const template = roomTemplates[chosenRoomName]; template.platforms.forEach(p_template => { const newPlatform = { x: generationCursor.x + p_template.x, y: generationCursor.y + p_template.y, width: p_template.width, height: 20 }; platforms.push(newPlatform); if (canSpawnEntities && chosenRoomName !== 'boss_arena' && transitionState === 'none') { if (Math.random() < 0.2) spawnItem(newPlatform); if (Math.random() < 0.25) spawnEnemy(newPlatform); } }); if (template.decorations) { template.decorations.forEach(d_template => { decorations.push({ emoji: d_template.emoji, x: generationCursor.x + d_template.x, y: generationCursor.y + d_template.y, width: 50, height: 100 }); }); } generationCursor.x += template.exit.x; generationCursor.y += template.exit.y; }
function spawnItem(platform) { const itemTypes = ['xp', 'health', 'star', 'boots', 'bolt']; const weights = [0.6, 0.2, 0.05, 0.075, 0.075]; let rand = Math.random(); let type = 'xp'; let cumulativeWeight = 0; for (let i = 0; i < itemTypes.length; i++) { cumulativeWeight += weights[i]; if (rand < cumulativeWeight) { type = itemTypes[i]; break; } } if (type === 'health' && player.health >= player.maxHealth) type = 'xp'; items.push({ x: platform.x + Math.random() * (platform.width - 30), y: platform.y - 40, width: 30, height: 30, type: type }); }
function spawnEnemy(platform) { let type = ['ghost', 'flyer', 'dragon'][Math.floor(Math.random() * 3)]; if (type === 'dragon' && platform.width < TILE_SIZE * 2.5) { type = 'ghost'; } const yPos = platform.y - 45; enemies.push({ x: platform.x + Math.random() * (platform.width - 40), y: yPos, width: 40, height: 40, type: type, vx: type === 'ghost' ? (Math.random() > 0.5 ? 1 : -1) * 1.5 : 0, vy: 0, platform: platform, initialY: yPos, shootCooldown: type === 'dragon' ? 180 : 0, isWarning: false, facingDirection: -1 }); }

function startBossTransition() { transitionColor = 'black'; if (transitionState === 'none') { transitionState = 'fadingOut'; } }
function startEndGameTransition() { transitionColor = 'white'; if (transitionState === 'none') { transitionState = 'fadingOut'; } }

function setupBossArena() {
    isBossFightActive = true;
    endPowerUp();
    const arenaCenterX = player.x; const arenaCenterY = player.y - 100;
    camera.x = arenaCenterX; camera.y = arenaCenterY; camera.targetZoom = 1.0;
    platforms = []; items = []; enemies = []; projectiles = []; particles = []; gravestones = []; decorations = []; circularShockwaves = []; visualEffects = [];
    const arenaWidth = canvas.width / camera.zoom; const arenaHeight = canvas.height / camera.zoom;
    const floor = { x: arenaCenterX - arenaWidth / 2, y: arenaCenterY + arenaHeight / 2 - 20, width: arenaWidth, height: 20 };
    const ceiling = { x: arenaCenterX - arenaWidth / 2, y: arenaCenterY - arenaHeight / 2, width: arenaWidth, height: 20 };
    const leftWall = { x: arenaCenterX - arenaWidth / 2, y: arenaCenterY - arenaHeight / 2, width: 20, height: arenaHeight };
    const rightWall = { x: arenaCenterX + arenaWidth / 2 - 20, y: arenaCenterY - arenaHeight / 2, width: 20, height: arenaHeight };
    platforms.push(floor, ceiling, leftWall, rightWall);
    if(bossesDefeated === 1) { const platY1_start = arenaCenterY + 120; const platY2_start = arenaCenterY - 40; platforms.push({ x: arenaCenterX - 150, y: platY1_start, width: 300, height: 20, isMoving: false, disappears: false, platformState: 'visible', platformTimer: 240, targetY: platY1_start + 40, moveSpeed: 1, minX: arenaCenterX - 250, maxX: arenaCenterX + 50 }); platforms.push({ x: arenaCenterX + 100, y: platY2_start, width: 150, height: 20, isMoving: false, disappears: false, platformState: 'visible', platformTimer: 240, targetY: platY2_start + 60, moveSpeed: -1.2, minX: arenaCenterX + 50, maxX: arenaCenterX + 250 }); platforms.push({ x: arenaCenterX - 250, y: platY2_start, width: 150, height: 20, isMoving: false, disappears: false, platformState: 'visible', platformTimer: 240, targetY: platY2_start + 60, moveSpeed: 1.2, minX: arenaCenterX - 250, maxX: arenaCenterX - 50 }); }
    player.x = leftWall.x + leftWall.width + 20;
    player.y = floor.y - player.height;
    player.vy = 0;
    setTimeout(initiateBossSpawn, 2000);
}

function setupReturnToLevel() {
    isBossFightActive = false;
    platforms = []; 
    generationCursor.x = camera.x + canvas.width / 2;
    generationCursor.y = camera.y;
    stampRoom(null, false);
    stampRoom(null, false);
    if (platforms.length > 0) {
        player.x = platforms[0].x + 50;
        player.y = platforms[0].y - player.height;
        player.vy = 0;
    }
    transitionColor = 'black';
}

function initiateBossSpawn() {
    if (!isBossFightActive) return;
    if (bossesDefeated === 0) { spawnGorillaBoss(); } 
    else if (bossesDefeated === 1) { spawnSentinelRobotBoss(); }
}

function spawnGorillaBoss() { const bossWidth = 80; const bossHeight = 80; const floor = platforms[0]; boss = { type: 'gorilla', x: camera.x + (canvas.width / 2) - bossWidth - 50, y: floor.y - bossHeight, width: bossWidth, height: bossHeight, emoji: 'ü¶ç', phase: 'easy', health: 3, maxHealthForPhase: 3, state: 'idle', stateTimer: 120, isVulnerable: false, invulnerabilityTimer: 0, vx: 0, vy: 0, targetX: 0, targetY: 0, groundY: floor.y - bossHeight, hasDoneSecondJump: false }; spawnExplosionParticles(boss.x + boss.width / 2, boss.y + boss.height / 2); }
function spawnSentinelRobotBoss() { const bossWidth = 70; const bossHeight = 70; const floor = platforms[0]; boss = { type: 'robot', x: camera.x, y: floor.y - bossHeight - 150, width: bossWidth, height: bossHeight, emoji: 'ü§ñ', phase: 'easy', health: 3, maxHealthForPhase: 3, state: 'idle', stateTimer: 120, isVulnerable: false, invulnerabilityTimer: 0, vx: 1.5, vy: 0, hoverY: floor.y - bossHeight - 150, laserCounter: 0, disappearingPlatformIndex: -1 }; spawnExplosionParticles(boss.x + boss.width / 2, boss.y + boss.height / 2); }

function spawnJumpParticles(x, y) { for (let i = 0; i < 8; i++) { particles.push({ x: x, y: y, vx: (Math.random() - 0.5) * 4, vy: (Math.random() * -3) - 1, size: Math.random() * 5 + 3, life: 30 + Math.random() * 20, color: `rgba(200, 200, 200, ${Math.random() * 0.5 + 0.3})` }); } }
function spawnExplosionParticles(x, y) { for (let i = 0; i < 20; i++) { particles.push({ x: x, y: y, vx: (Math.random() - 0.5) * 6, vy: (Math.random() - 0.5) * 6, size: Math.random() * 8 + 4, life: 25 + Math.random() * 15, color: `rgba(255, 150, 50, ${Math.random() * 0.5 + 0.4})` }); } }
function spawnSpeedParticles(x, y) { particles.push({ x: x, y: y + (Math.random() - 0.5) * player.height * 0.8, vx: -player.vx * 0.2, vy: (Math.random() - 0.5) * 2, size: Math.random() * 4 + 2, life: 15 + Math.random() * 10, color: `rgba(255, 220, 0, ${Math.random() * 0.5 + 0.5})` }); }
function spawnHudParticles(x, y, color) { for (let i = 0; i < 15; i++) { hudParticles.push({ x: x, y: y, vx: (Math.random() - 0.5) * 5, vy: (Math.random() - 0.5) * 5, size: Math.random() * 4 + 2, life: 40 + Math.random() * 20, color: `rgba(${color}, ${Math.random() * 0.6 + 0.4})` }); } }
function spawnGroundParticles(x, y) { const groundColor = { r: 74, g: 74, b: 74 }; for (let i = 0; i < 10; i++) { particles.push({ x: x + (Math.random() - 0.5) * boss.width, y: y, vx: (Math.random() - 0.5) * 3, vy: (Math.random() * -2), size: Math.random() * 4 + 2, life: 25 + Math.random() * 15, color: `rgba(${groundColor.r + Math.floor(Math.random() * 20)}, ${groundColor.g + Math.floor(Math.random() * 20)}, ${groundColor.b + Math.floor(Math.random() * 20)}, ${Math.random() * 0.5 + 0.4})` }); } }
function updateParticles(particleArray) { for (let i = particleArray.length - 1; i >= 0; i--) { const p = particleArray[i]; p.x += p.vx; p.y += p.vy; p.vy += 0.1; p.life--; p.size *= 0.98; if (p.life <= 0 || p.size < 0.5) { particleArray.splice(i, 1); } } }
function updateVisualEffects() { for (let i = visualEffects.length - 1; i >= 0; i--) { const effect = visualEffects[i]; effect.life--; if (effect.life <= 0) { visualEffects.splice(i, 1); } } }

function updateBoss() {
    if (!boss) return;
    if (boss.type === 'gorilla') { updateGorillaBoss(); } 
    else if (boss.type === 'robot') { updateSentinelRobotBoss(); }
}

function updateGorillaBoss() { if (boss.stateTimer > 0) boss.stateTimer--; if (boss.invulnerabilityTimer > 0) boss.invulnerabilityTimer--; if (boss.state !== 'climbing' && boss.state !== 'on_wall' && boss.state !== 'on_ceiling') { boss.vy += GRAVITY; boss.vy = Math.min(boss.vy, MAX_FALL_SPEED); } boss.y += boss.vy; boss.x += boss.vx; if (boss.y > boss.groundY) { boss.y = boss.groundY; boss.vy = 0; if (boss.state === 'jumping' || boss.state === 'falling') { spawnGroundParticles(boss.x + boss.width / 2, boss.groundY + boss.height); boss.state = (boss.phase === 'hard' && boss.state === 'falling') ? 'landing_hard' : 'landing'; boss.stateTimer = 30; } } if (boss.state === 'climbing') { if (boss.x <= camera.x - canvas.width / 2 + 20 || boss.x + boss.width >= camera.x + canvas.width / 2 - 20) { boss.vx = 0; boss.vy = -PLAYER_SPEED; boss.state = 'on_wall'; } } if (boss.state === 'on_wall' && boss.y <= camera.y - canvas.height / 2) { boss.vy = 0; boss.state = 'on_ceiling'; } switch (boss.phase) { case 'easy': handleGorillaEasyPhase(); break; case 'medium': handleGorillaMediumPhase(); break; case 'hard': handleGorillaHardPhase(); break; } }
function updateSentinelRobotBoss() { if (!boss) return; if (boss.stateTimer > 0) boss.stateTimer--; if (boss.invulnerabilityTimer > 0) boss.invulnerabilityTimer--; if (['idle', 'cooldown', 'drop_mines'].includes(boss.state)) { boss.y = boss.hoverY + Math.sin(Date.now() / 400) * 15; boss.x += boss.vx; const leftPatrol = camera.x - canvas.width / 2 + 50; const rightPatrol = camera.x + canvas.width / 2 - 50; if (boss.x < leftPatrol || boss.x + boss.width > rightPatrol) { boss.vx *= -1; } } switch(boss.phase) { case 'easy': handleSentinelEasyPhase(); break; case 'medium': handleSentinelMediumPhase(); break; case 'hard': handleSentinelHardPhase(); break; } }

function handleGorillaEasyPhase() { switch (boss.state) { case 'idle': if (boss.stateTimer <= 0) { if (Math.random() < 0.5) { boss.state = 'jump_charge'; boss.stateTimer = 45; } else { boss.state = 'throw_charge'; boss.targetX = player.x; boss.stateTimer = 60; } } break; case 'jump_charge': if (boss.stateTimer <= 0) { boss.state = 'jumping'; boss.vy = JUMP_FORCE * 1.8; } break; case 'jumping': triggerBackgroundFlash({r: 100, g: 0, b: 0}, 5); break; case 'landing': if (boss.stateTimer === 29) { camera.shakeDuration = 40; camera.shakeMagnitude = 12; if (player.onGround) { takeDamage(1); } } if (boss.stateTimer <= 0) { boss.state = 'vulnerable'; boss.stateTimer = 180; boss.isVulnerable = true; } break; case 'throw_charge': if(boss.stateTimer <= 0){ boss.state = 'throw_attack'; boss.stateTimer = 30; } break; case 'throw_attack': if (boss.stateTimer === 29) { const dx = boss.targetX - (boss.x + boss.width / 2); const launchAngleRad = Math.PI / 3; const g_effective = GRAVITY * 0.5; const range = Math.max(1, Math.abs(dx)); const v0 = Math.sqrt((range * g_effective) / Math.sin(2 * launchAngleRad)); let vx = v0 * Math.cos(launchAngleRad); let vy = -v0 * Math.sin(launchAngleRad); if (dx < 0) vx *= -1; projectiles.push({ x: boss.x + boss.width / 2, y: boss.y + boss.height / 2, width: 30, height: 30, vx: vx, vy: vy, type: 'barrel' }); } if (boss.stateTimer <= 0) { boss.state = 'idle'; boss.stateTimer = 90; } break; case 'vulnerable': if (boss.stateTimer <= 0) { boss.isVulnerable = false; boss.state = 'idle'; boss.stateTimer = 120; } break; case 'transitioning': boss.health = 1; boss.maxHealthForPhase = 1; boss.phase = 'medium'; boss.state = 'idle'; boss.stateTimer = 120; camera.shakeDuration = 60; camera.shakeMagnitude = 10; spawnExplosionParticles(boss.x + boss.width / 2, boss.y + boss.height / 2); break; } }
function handleGorillaMediumPhase() { switch (boss.state) { case 'idle': if (boss.stateTimer <= 0) { const rand = Math.random(); if (rand < 0.4) { boss.state = 'jump_charge'; boss.stateTimer = 35; } else if (rand < 0.8) { boss.state = 'throw_charge_1'; boss.targetX = player.x; boss.stateTimer = 45; } else { boss.state = 'climb_charge'; boss.stateTimer = 60; } } break; case 'jump_charge': if (boss.stateTimer <= 0) { boss.state = 'jumping'; boss.vy = JUMP_FORCE * 1.9; } break; case 'jumping': triggerBackgroundFlash({r: 100, g: 0, b: 0}, 5); break; case 'landing': if (boss.stateTimer === 29) { camera.shakeDuration = 45; camera.shakeMagnitude = 14; if (player.onGround) { takeDamage(1); } } if (boss.stateTimer <= 0) { if (Math.random() < 0.4) { boss.state = 'jump_charge'; boss.stateTimer = 35; } else { boss.state = 'vulnerable'; boss.stateTimer = 120; boss.isVulnerable = true; } } break; case 'throw_charge_1': if(boss.stateTimer <= 0){ boss.state = 'throw_attack_1'; boss.stateTimer = 20; } break; case 'throw_attack_1': if (boss.stateTimer === 19) { const dx = player.x - (boss.x + boss.width / 2); const distance = Math.abs(dx); let initialVy = -10 - (distance * 0.015); const timeToPeak = -initialVy / (GRAVITY * 0.5); const flightTime = timeToPeak * 2.2; const vx = dx / flightTime; projectiles.push({ x: boss.x + boss.width / 2, y: boss.y + boss.height / 2, width: 30, height: 30, vx: vx, vy: initialVy, type: 'barrel' }); } if (boss.stateTimer <= 0) { boss.state = 'throw_attack_2'; boss.stateTimer = 20; } break; case 'throw_attack_2': if (boss.stateTimer === 19) { const dx = player.x - (boss.x + boss.width / 2); const distance = Math.abs(dx); let initialVy = -12 - (distance * 0.01); const timeToPeak = -initialVy / (GRAVITY * 0.5); const flightTime = timeToPeak * 2; const vx = dx / flightTime; projectiles.push({ x: boss.x + boss.width / 2, y: boss.y + boss.height / 2, width: 30, height: 30, vx: vx, vy: initialVy, type: 'barrel' }); } if (boss.stateTimer <= 0) { boss.state = 'idle'; boss.stateTimer = 75; } break; case 'climb_charge': if(boss.stateTimer <= 0){ boss.state = 'climbing'; const leftWall = platforms[2]; const rightWall = platforms[3]; const leftWallDist = Math.abs(boss.x - leftWall.x); const rightWallDist = Math.abs(boss.x - rightWall.x); boss.vx = (leftWallDist < rightWallDist) ? -PLAYER_SPEED : PLAYER_SPEED; } break; case 'climbing': boss.vx = boss.vx; break; case 'on_wall': boss.vy = -PLAYER_SPEED; break; case 'on_ceiling': boss.vx = player.x > boss.x ? PLAYER_SPEED * 0.8 : -PLAYER_SPEED * 0.8; if(Math.abs(player.x - boss.x) < 20) { boss.vx = 0; boss.state = 'falling'; } break; case 'falling': break; case 'vulnerable': if (boss.stateTimer <= 0) { boss.isVulnerable = false; boss.state = 'idle'; boss.stateTimer = 120; } break; case 'transitioning': boss.health = 2; boss.maxHealthForPhase = 2; boss.phase = 'hard'; boss.state = 'idle'; boss.stateTimer = 120; camera.shakeDuration = 60; camera.shakeMagnitude = 10; spawnExplosionParticles(boss.x + boss.width / 2, boss.y + boss.height / 2); break; } }
function handleGorillaHardPhase() { switch (boss.state) { case 'idle': if (boss.stateTimer <= 0) { const rand = Math.random(); if (rand < 0.33) { boss.state = 'jump_charge'; boss.stateTimer = 25; boss.hasDoneSecondJump = false; } else if (rand < 0.66) { boss.state = 'throw_charge_1'; boss.targetX = player.x; boss.stateTimer = 30; } else { boss.state = 'climb_charge'; boss.stateTimer = 50; } } break; case 'jump_charge': if (boss.stateTimer <= 0) { boss.state = 'jumping'; boss.vy = JUMP_FORCE * 2.0; } break; case 'jumping': triggerBackgroundFlash({r: 100, g: 0, b: 0}, 5); break; case 'landing': if (boss.stateTimer === 29) { camera.shakeDuration = 50; camera.shakeMagnitude = 15; if(player.onGround) takeDamage(2); } if (boss.stateTimer <= 0) { if (!boss.hasDoneSecondJump) { boss.state = 'jump_charge_2'; boss.stateTimer = 25; boss.hasDoneSecondJump = true; } else { boss.state = 'idle'; boss.stateTimer = 90; } } break; case 'jump_charge_2': if (boss.stateTimer <= 0) { boss.state = 'jumping'; boss.vy = JUMP_FORCE * 2.0; } break; case 'throw_charge_1': if(boss.stateTimer <= 0){ boss.state = 'throw_attack_1'; boss.stateTimer = 15; } break; case 'throw_attack_1': if (boss.stateTimer === 14) { const dx = player.x - 100 - (boss.x + boss.width / 2); const distance = Math.abs(dx); let initialVy = -12 - (distance * 0.01); const timeToPeak = -initialVy / (GRAVITY * 0.5); const flightTime = timeToPeak * 2; const vx = dx / flightTime; projectiles.push({ x: boss.x + boss.width / 2, y: boss.y + boss.height / 2, width: 30, height: 30, vx: vx, vy: initialVy, type: 'barrel' }); } if (boss.stateTimer <= 0) { boss.state = 'throw_attack_2'; boss.stateTimer = 15; } break; case 'throw_attack_2': if (boss.stateTimer === 14) { const dx = player.x - (boss.x + boss.width / 2); const distance = Math.abs(dx); let initialVy = -14 - (distance * 0.01); const timeToPeak = -initialVy / (GRAVITY * 0.5); const flightTime = timeToPeak * 2; const vx = dx / flightTime; projectiles.push({ x: boss.x + boss.width / 2, y: boss.y + boss.height / 2, width: 30, height: 30, vx: vx, vy: initialVy, type: 'barrel' }); } if (boss.stateTimer <= 0) { boss.state = 'throw_attack_3'; boss.stateTimer = 15; } break; case 'throw_attack_3': if (boss.stateTimer === 14) { const dx = player.x + 100 - (boss.x + boss.width / 2); const distance = Math.abs(dx); let initialVy = -12 - (distance * 0.01); const timeToPeak = -initialVy / (GRAVITY * 0.5); const flightTime = timeToPeak * 2; const vx = dx / flightTime; projectiles.push({ x: boss.x + boss.width / 2, y: boss.y + boss.height / 2, width: 30, height: 30, vx: vx, vy: initialVy, type: 'barrel' }); } if (boss.stateTimer <= 0) { boss.state = 'idle'; boss.stateTimer = 60; } break; case 'climb_charge': if(boss.stateTimer <= 0){ boss.state = 'climbing'; const leftWall = platforms[2]; const rightWall = platforms[3]; const leftWallDist = Math.abs(boss.x - leftWall.x); const rightWallDist = Math.abs(boss.x - rightWall.x); boss.vx = (leftWallDist < rightWallDist) ? -PLAYER_SPEED * 1.2 : PLAYER_SPEED * 1.2; } break; case 'climbing': boss.vx = boss.vx; break; case 'on_wall': boss.vy = -PLAYER_SPEED * 1.2; break; case 'on_ceiling': boss.vx = player.x > boss.x ? PLAYER_SPEED : -PLAYER_SPEED; if(Math.abs(player.x - boss.x) < 20) { boss.vx = 0; boss.state = 'falling'; } break; case 'falling': break; case 'landing_hard': if (boss.stateTimer === 29) { camera.shakeDuration = 60; camera.shakeMagnitude = 20; if (player.onGround) { takeDamage(2); } circularShockwaves.push({ x: boss.x + boss.width/2, y: boss.groundY + boss.height - 10, radius: 20, maxRadius: canvas.width/2, speed: 6}); } if (boss.stateTimer <= 0) { boss.state = 'vulnerable'; boss.stateTimer = 120; boss.isVulnerable = true; } break; case 'vulnerable': if (boss.stateTimer <= 0) { boss.isVulnerable = false; boss.state = 'idle'; boss.stateTimer = 90; } break; case 'defeated': boss.y += 2; boss.vy = 0; boss.vx = 0; if(boss.stateTimer % 10 === 0) spawnExplosionParticles(boss.x + Math.random() * boss.width, boss.y + Math.random() * boss.height); if(boss.stateTimer <= 0) { bossesDefeated++; boss = null; startEndGameTransition(); } break; } }
function handleSentinelEasyPhase() { switch(boss.state) { case 'idle': if (boss.stateTimer <= 0) { boss.state = 'aiming'; boss.stateTimer = 60; boss.targetX = player.x + player.width/2; boss.targetY = player.y + player.height/2; } break; case 'aiming': boss.vx = 0; if(boss.stateTimer <= 1){ boss.state = 'firing'; boss.stateTimer = 20; } break; case 'firing': if (boss.stateTimer === 19) { const dx = boss.targetX - (boss.x + boss.width / 2); const dy = boss.targetY - (boss.y + boss.height / 2); const dist = Math.sqrt(dx * dx + dy * dy); const laserSpeed = 4; const lvx = (dx / dist) * laserSpeed; const lvy = (dy / dist) * laserSpeed; projectiles.push({ x: boss.x + boss.width / 2, y: boss.y + boss.height / 2, width: 80, height: 10, vx: lvx, vy: lvy, type: 'laser', life: 120, angle: Math.atan2(dy, dx) }); boss.laserCounter++; } if (boss.stateTimer <= 0) { if (boss.laserCounter >= 3) { boss.state = 'vulnerable'; boss.stateTimer = 180; boss.isVulnerable = true; } else { boss.state = 'cooldown'; boss.stateTimer = 40; } } break; case 'cooldown': if (boss.stateTimer <= 0) { boss.state = 'aiming'; boss.stateTimer = 60; boss.targetX = player.x + player.width / 2; boss.targetY = player.y + player.height / 2; } break; case 'vulnerable': if (boss.stateTimer <= 0) { boss.isVulnerable = false; boss.state = 'idle'; boss.laserCounter = 0; boss.vx = 1.5 * (Math.random() < 0.5 ? 1 : -1); boss.stateTimer = 180; } break; case 'transitioning': boss.health = 1; boss.maxHealthForPhase = 1; boss.phase = 'medium'; boss.state = 'idle'; boss.stateTimer = 120; platforms.forEach(p => { if(p.isMoving !== undefined) { p.isMoving = true; } }); break; } }
function handleSentinelMediumPhase() { switch(boss.state) { case 'idle': if (boss.stateTimer <= 0) { if (Math.random() < 0.5) { boss.state = 'sweep_charge'; boss.stateTimer = 90; } else { boss.state = 'aiming'; boss.laserCounter = 0; boss.stateTimer = 45; } } break; case 'aiming': boss.vx = 0; if(boss.stateTimer <= 1){ boss.state = 'firing'; boss.stateTimer = 45; } break; case 'firing': if (boss.stateTimer === 44 || boss.stateTimer === 29 || boss.stateTimer === 14) { const dx = player.x + (player.width/2) - (boss.x + boss.width / 2); const dy = player.y + (player.height/2) - (boss.y + boss.height / 2); const dist = Math.sqrt(dx*dx+dy*dy); const laserSpeed = 5; const lvx = (dx/dist)*laserSpeed; const lvy = (dy/dist)*laserSpeed; projectiles.push({ x: boss.x + boss.width / 2, y: boss.y + boss.height / 2, width: 80, height: 10, vx: lvx, vy: lvy, type: 'laser', life: 120, angle: Math.atan2(dy, dx) }); } if(boss.stateTimer <= 0) { boss.state = 'idle'; boss.stateTimer = 90; boss.vx = 1.5 * (Math.random() < 0.5 ? 1 : -1); } break; case 'sweep_charge': boss.vx = 0; if(boss.stateTimer === 89) { let startX = (Math.random() < 0.5) ? camera.x - canvas.width / 2 : camera.x + canvas.width / 2; visualEffects.push({type: 'warning_line', x: startX, life: 88}); } if(boss.stateTimer <= 1) { boss.state = 'sweeping'; const effect = visualEffects.find(e => e.type === 'warning_line'); let startX = effect ? effect.x : camera.x - canvas.width/2; let sweepVx = startX < camera.x ? 3 : -3; projectiles.push({ x: startX, y: camera.y - canvas.height/2, width: 15, height: canvas.height, vx: sweepVx, vy: 0, type: 'laser_beam', life: 240}); } break; case 'sweeping': if(projectiles.every(p => p.type !== 'laser_beam')) { boss.state = 'vulnerable'; boss.stateTimer = 120; boss.isVulnerable = true; } break; case 'vulnerable': if (boss.stateTimer <= 0) { boss.isVulnerable = false; boss.state = 'idle'; boss.vx = 1.5 * (Math.random() < 0.5 ? 1 : -1); boss.stateTimer = 120; } break; case 'transitioning': boss.health = 2; boss.maxHealthForPhase = 2; boss.phase = 'hard'; boss.state = 'idle'; boss.stateTimer = 120; platforms.forEach(p => { if(p.disappears !== undefined) { p.disappears = true; } }); pickNewDisappearingPlatform(); break; } }
function handleSentinelHardPhase() { switch(boss.state) { case 'idle': if (boss.stateTimer <= 0) { const rand = Math.random(); if (rand < 0.4) { boss.state = 'aiming'; boss.stateTimer = 20; } else if (rand < 0.7) { boss.state = 'sweep_charge'; boss.stateTimer = 75; } else { boss.state = 'drop_mines'; boss.stateTimer = 1; } } break; case 'aiming': boss.vx = 0; if(boss.stateTimer <= 1){ boss.state = 'firing'; boss.stateTimer = 50; } break; case 'firing': if (boss.stateTimer % 10 === 9) { const dx = player.x + (player.width/2) - (boss.x + boss.width / 2); const dy = player.y + (player.height/2) - (boss.y + boss.height / 2); const dist = Math.sqrt(dx*dx+dy*dy); const laserSpeed = 6; const lvx = (dx/dist)*laserSpeed; const lvy = (dy/dist)*laserSpeed; projectiles.push({ x: boss.x + boss.width / 2, y: boss.y + boss.height / 2, width: 80, height: 10, vx: lvx, vy: lvy, type: 'laser', life: 120, angle: Math.atan2(dy, dx) }); } if(boss.stateTimer <= 0) { boss.state = 'idle'; boss.stateTimer = 60; boss.vx = 1.5 * (Math.random() < 0.5 ? 1 : -1); } break; case 'sweep_charge': boss.vx = 0; if(boss.stateTimer === 74) { let startPos, type; if(Math.random() < 0.5) { type = 'v_warning_line'; startPos = (Math.random() < 0.5) ? camera.x - canvas.width / 2 : camera.x + canvas.width / 2; } else { type = 'h_warning_line'; startPos = (Math.random() < 0.5) ? camera.y - canvas.height / 2 : camera.y + canvas.height / 2; } visualEffects.push({type: type, pos: startPos, life: 73}); } if(boss.stateTimer <= 1) { boss.state = 'sweeping'; const effect = visualEffects.find(e => e.type.includes('warning_line')); const sweepSpeed = 3 + Math.random() * 2; if(effect && effect.type === 'v_warning_line') { const travelTime = (canvas.width * 0.65) / sweepSpeed; let startX = effect.pos; let sweepVx = startX < camera.x ? sweepSpeed : -sweepSpeed; projectiles.push({ x: startX, y: camera.y - canvas.height/2, width: 15, height: canvas.height, vx: sweepVx, vy: 0, type: 'laser_beam', life: travelTime}); } else { const travelTime = (canvas.height * 0.65) / sweepSpeed; let startY = effect ? effect.pos : camera.y - canvas.height/2; let sweepVy = startY < camera.y ? sweepSpeed : -sweepSpeed; projectiles.push({ x: camera.x - canvas.width/2, y: startY, width: canvas.width, height: 15, vx: 0, vy: sweepVy, type: 'laser_beam', life: travelTime}); } } break; case 'sweeping': if(projectiles.every(p => p.type !== 'laser_beam')) { boss.state = 'idle'; boss.stateTimer = 60; } break; case 'drop_mines': if (boss.stateTimer === 0) { projectiles.push({ x: boss.x + boss.width/2, y: boss.y + boss.height, width: 25, height: 25, vx: 0, vy: 0, type: 'mine' }); boss.state = 'post_mine_attack'; boss.stateTimer = 30; } break; case 'post_mine_attack': if(boss.stateTimer <= 0) { const rand = Math.random(); if (rand < 0.66) { boss.state = 'aiming'; boss.stateTimer = 20; } else { boss.state = 'sweep_charge'; boss.stateTimer = 75; } } break; case 'vulnerable': if (boss.stateTimer <= 0) { boss.isVulnerable = false; boss.state = 'idle'; boss.vx = 1.5 * (Math.random() < 0.5 ? 1 : -1); boss.stateTimer = 120; } break; case 'defeated': boss.y += 2; boss.vy = 0; boss.vx = 0; if(boss.stateTimer % 10 === 0) spawnExplosionParticles(boss.x + Math.random() * boss.width, boss.y + Math.random() * boss.height); if(boss.stateTimer <= 0) { bossesDefeated++; boss = null; startEndGameTransition(); } break; } }
function updateCircularShockwaves() { for (let i = circularShockwaves.length - 1; i >= 0; i--) { const sw = circularShockwaves[i]; sw.radius += sw.speed; const dist = Math.abs((player.x + player.width / 2) - sw.x); if (player.onGround && Math.abs(dist - sw.radius) < (sw.speed + player.width/2) ) { takeDamage(2); circularShockwaves.splice(i,1); continue; } if (sw.radius > sw.maxRadius) { circularShockwaves.splice(i, 1); } } }

function pickNewDisappearingPlatform() {
    if(!boss) return;
    const platformIndices = [4, 5, 6];
    const availableIndices = platformIndices.filter(index => index !== boss.disappearingPlatformIndex);
    const newIndex = availableIndices[Math.floor(Math.random() * availableIndices.length)];
    boss.disappearingPlatformIndex = newIndex;
    if(platforms[boss.disappearingPlatformIndex]) {
        platforms[boss.disappearingPlatformIndex].platformTimer = 240;
        platforms[boss.disappearingPlatformIndex].platformState = 'visible';
    }
}

function update() { if (transitionState === 'fadingOut') { transitionAlpha = Math.min(1, transitionAlpha + 0.03); if (transitionAlpha >= 1) { if (!isBossFightActive) { setupBossArena(); } else { setupReturnToLevel(); } transitionState = 'fadingIn'; } return; } if (transitionState === 'fadingIn') { transitionAlpha = Math.max(0, transitionAlpha - 0.03); if (transitionAlpha <= 0) { transitionState = 'none'; } } if (player.isDying) { player.vy += GRAVITY * 0.8; player.y += player.vy; player.rotation += 15; if (player.y > camera.y + canvas.height + 100) { showGameOverScreen(); } updateParticles(particles); updateParticles(hudParticles); return; } if (!isBossFightActive) { canEnterDoor = false; const door = decorations.find(d => d.emoji === 'üö™'); if (door) { const checkBuffer = 20; if (player.x < door.x + door.width + checkBuffer && player.x + player.width > door.x - checkBuffer && player.y < door.y + door.height && player.y + player.height > door.y) { canEnterDoor = true; } } } let playerGroundedOnPlatform = null; player.vx = 0; if (keys.left) { player.vx = -player.speed * player.speedMultiplier; player.facingRight = false; } if (keys.right) { player.vx = player.speed * player.speedMultiplier; player.facingRight = true; } const wasOnGround = player.onGround; player.onGround = false; if (isBossFightActive) { for (let i = 0; i < platforms.length; i++) { const platform = platforms[i]; if(platform.disappears && platform.platformState === 'invisible') continue; if (i < 4) { if (player.x + player.width > platform.x && player.x < platform.x + platform.width && player.y + player.height > platform.y && player.y < platform.y + platform.height) { if (player.vy >= 0 && (player.y + player.height - player.vy) <= platform.y + 10) { player.y = platform.y - player.height; player.vy = 0; player.onGround = true; playerGroundedOnPlatform = platform; player.doubleJumpUsed = false; } if (player.vy < 0 && (player.y - player.vy) >= (platform.y + platform.height)) { player.y = platform.y + platform.height; player.vy = 0; } if (player.vx > 0 && (player.x + player.width - player.vx) <= platform.x) { player.x = platform.x - player.width; } if (player.vx < 0 && (player.x - player.vx) >= (platform.x + platform.width)) { player.x = platform.x + platform.width; } } } else { if (player.x + player.width > platform.x && player.x < platform.x + platform.width && player.vy >= 0) { const previousPlayerBottom = (player.y + player.height) - player.vy; if (previousPlayerBottom <= platform.y && (player.y + player.height) >= platform.y) { player.y = platform.y - player.height; player.vy = 0; player.onGround = true; playerGroundedOnPlatform = platform; player.doubleJumpUsed = false; } } } } } else { for(const platform of platforms) { if(platform.x < player.x + canvas.width && platform.x + platform.width > player.x - canvas.width) { if (player.x + player.width > platform.x && player.x < platform.x + platform.width && player.vy >= 0) { const previousPlayerBottom = (player.y + player.height) - player.vy; if (previousPlayerBottom <= platform.y && (player.y + player.height) >= platform.y) { player.y = platform.y - player.height; player.vy = 0; player.onGround = true; playerGroundedOnPlatform = platform; player.doubleJumpUsed = false; } } } } } 
    projectiles.forEach(p => { if (p.type === 'mine' && p.countdown > 0) { if (player.x + player.width > p.x && player.x < p.x + p.width && player.vy >= 0) { const previousPlayerBottom = (player.y + player.height) - player.vy; if (previousPlayerBottom <= p.y && (player.y + player.height) >= p.y) { player.y = p.y - player.height; player.vy = 0; player.onGround = true; playerGroundedOnPlatform = p; player.doubleJumpUsed = false; } } } });
    player.vy += GRAVITY; player.vy = Math.min(player.vy, MAX_FALL_SPEED); if (playerGroundedOnPlatform && playerGroundedOnPlatform.isMoving) { player.x += playerGroundedOnPlatform.moveSpeed; } player.x += player.vx; player.y += player.vy; if (player.onGround) { player.coyoteTimeCounter = COYOTE_TIME_FRAMES; } else { if (wasOnGround) { player.coyoteTimeCounter = COYOTE_TIME_FRAMES; } else { player.coyoteTimeCounter--; } } if (player.jumpBufferCounter > 0) { if (player.onGround) { player.vy = JUMP_FORCE; player.onGround = false; spawnJumpParticles(player.x + player.width / 2, player.y + player.height); player.jumpBufferCounter = 0; } else { player.jumpBufferCounter--; } } 
    platforms.forEach((p, i) => { if(p.isMoving) { p.x += p.moveSpeed; if ((p.moveSpeed > 0 && p.x + p.width > p.maxX) || (p.moveSpeed < 0 && p.x < p.minX)) { p.moveSpeed *= -1; } } if(p.targetY && Math.abs(p.y - p.targetY) > 0.5) { p.y += (p.targetY - p.y) * 0.05; } if(p.disappears) { if(boss && i === boss.disappearingPlatformIndex) { p.platformTimer--; if(p.platformTimer <= 0) { if(p.platformState === 'visible') { p.platformState = 'warning'; p.platformTimer = 60; } else if (p.platformState === 'warning') { p.platformState = 'invisible'; p.platformTimer = 120; } else if (p.platformState === 'invisible') { p.platformState = 'visible'; pickNewDisappearingPlatform(); } } } else { p.platformState = 'visible'; } } }); 
    if (isBossFightActive) { updateBoss(); updateCircularShockwaves(); if (boss && boss.invulnerabilityTimer <= 0 && boss.state !== 'defeated' && player.x < boss.x + boss.width && player.x + player.width > boss.x && player.y < boss.y + boss.height && player.y + player.height > boss.y) { if (boss.isVulnerable && player.vy > 0) { boss.health--; boss.isVulnerable = false; boss.invulnerabilityTimer = 120; player.vy = STOMP_BOUNCE; camera.shakeDuration = 15; camera.shakeMagnitude = 6; if (boss.health <= 0) { if (boss.phase === 'hard') { boss.state = 'defeated'; boss.stateTimer = 180; } else { boss.state = 'transitioning'; } } } else { takeDamage(boss.type === 'robot' ? 1 : 2); } } } else { items.forEach((item, index) => { if (player.x < item.x + item.width && player.x + player.width > item.x && player.y < item.y + item.height && player.y + player.height > item.y) { collectItem(item.type); items.splice(index, 1); } }); enemies.forEach((enemy, index) => { if (player.x < enemy.x + enemy.width && player.x + player.width > enemy.x && player.y < enemy.y + enemy.height && player.y + player.height > enemy.y) { const isStomp = player.vy > 0 && (player.y + player.height - player.vy) <= enemy.y + 10; const isStarKill = player.isImmune && player.powerUp === 'star'; if (isStomp || isStarKill) { let isOverVoid = true; const checkDistance = 50; for (const p of platforms) { if (enemy.x + enemy.width > p.x && enemy.x < p.x + p.width && enemy.y < p.y && p.y < enemy.y + enemy.height + checkDistance) { isOverVoid = false; break; } } if (isOverVoid) { let closestPlatformAbove = null; let minDistance = Infinity; for (const p of platforms) { if (enemy.x + enemy.width > p.x && enemy.x < p.x + p.width && p.y < enemy.y) { const distance = enemy.y - (p.y + p.height); if (distance < minDistance) { minDistance = distance; closestPlatformAbove = p; } } } if (closestPlatformAbove) { const jumpHeight = minDistance + player.height; player.vy = -Math.sqrt(2 * GRAVITY * jumpHeight) * 1.1; } else { player.vy = JUMP_FORCE * 1.2; } } else if (isStomp) { player.vy = STOMP_BOUNCE; } spawnExplosionParticles(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2); enemies.splice(index, 1); player.xp += 10; xpShakeTimer = 20; triggerKillEffects(); updateBossEligibility(); } else if (!player.isImmune) { takeDamage(enemy.type === 'ghost' ? 1 : 2); } } }); const despawnX = camera.x - canvas.width; platforms = platforms.filter(p => p.x + p.width > despawnX); items = items.filter(i => i.x + i.width > despawnX); enemies = enemies.filter(e => e.x + e.width > despawnX); gravestones = gravestones.filter(g => g.x > despawnX); decorations = decorations.filter(d => d.x + 200 > despawnX); } 
    for (let i = projectiles.length - 1; i >= 0; i--) { const p = projectiles[i]; if(!p) continue; p.x += p.vx; if(p.vy !== undefined) p.y += p.vy; if (p.type === 'barrel' || p.type === 'mine') { p.vy += GRAVITY * 0.5; } if (p.life) { p.life--; if (p.life <= 0) { projectiles.splice(i,1); continue; } } if(p.type === 'mine') { let landed = false; const checkPlatforms = [...platforms, ...projectiles.filter(pr => pr.type === 'mine' && pr !== p)]; for(const platform of checkPlatforms) { if(!platform || (platform.disappears && platform.platformState === 'invisible')) continue; if(p.x < platform.x + platform.width && p.x + p.width > platform.x && p.y + p.height >= platform.y && p.y < platform.y + platform.height && p.vy > 0) { p.vy = 0; p.y = platform.y - p.height; if(!p.countdown) p.countdown = 480; landed = true; break; } } if(landed && p.countdown) { p.countdown--; if(p.countdown <= 0) { spawnExplosionParticles(p.x + p.width/2, p.y + p.height/2); projectiles.splice(i,1); continue; } } } if(projectiles[i] && projectiles[i].type !== 'mine' && player.x < projectiles[i].x + projectiles[i].width && player.x + player.width > projectiles[i].x && player.y < projectiles[i].y + projectiles[i].height && player.y + player.height > projectiles[i].y) { if (!player.isImmune) takeDamage(projectiles[i].type === 'barrel' ? 2 : 1); projectiles.splice(i, 1); continue; } if (projectiles[i] && (projectiles[i].y > camera.y + canvas.height / 2 || (projectiles[i].life && projectiles[i].life <=0)) ) { projectiles.splice(i, 1); continue; } } 
    if(boss && boss.phase === 'hard') { for (let i = projectiles.length - 1; i >= 0; i--) { if(!projectiles[i] || projectiles[i].type !== 'laser') continue; for (let j = projectiles.length - 1; j >= 0; j--) { if(i === j || !projectiles[j] || projectiles[j].type !== 'mine' || !projectiles[j].countdown) continue; const laser = projectiles[i]; const mine = projectiles[j]; if(laser.x < mine.x + mine.width && laser.x + laser.width > mine.x && laser.y < mine.y + mine.height && laser.y + laser.height > mine.y) { spawnExplosionParticles(mine.x + mine.width/2, mine.y + mine.height/2); if (i > j) { projectiles.splice(i, 1); projectiles.splice(j, 1); } else { projectiles.splice(j, 1); projectiles.splice(i, 1); } boss.state = 'vulnerable'; boss.stateTimer = 90; boss.isVulnerable = true; i = -1; break; } } } } 
    if (!isBossFightActive) { if (camera.zoomOverrideTimer > 0) { camera.zoomOverrideTimer--; } else { camera.targetZoom = player.vx !== 0 ? 1.1 : 1.0; } camera.x += (player.x - camera.x) * 0.05; camera.y += (player.y - camera.y) * 0.05; if (player.x > generationCursor.x - canvas.width * 2) { stampRoom(null, transitionState === 'none'); } } else { camera.zoom += (1.0 - camera.zoom) * 0.04; } updateEnemies(); updatePowerUp(); updateParticles(particles); updateParticles(hudParticles); updateVisualEffects(); if (player.powerUp === 'bolt' && player.vx !== 0) { if (Math.random() < 0.7) { spawnSpeedParticles(player.x + player.width / 2, player.y + player.height / 2); } } if (xpShakeTimer > 0) { const shakeX = (Math.random() - 0.5) * 8; const shakeY = (Math.random() - 0.5) * 8; xpTextDisplay.style.transform = `translate(${shakeX}px, ${shakeY}px) scale(1.5) rotate(10deg)`; xpTextDisplay.style.color = 'yellow'; xpTextDisplay.style.fontWeight = 'bold'; xpShakeTimer--; } else { xpTextDisplay.style.transform = 'translate(0, 0) scale(1) rotate(0deg)'; xpTextDisplay.style.color = 'white'; xpTextDisplay.style.fontWeight = 'normal'; } const bottomOfScreen = camera.y + (canvas.height / 2) / camera.zoom; if (!isBossFightActive && player.y > bottomOfScreen) { startDeathSequence(); } if (bgFlashTimer > 0) { bgFlashTimer--; } else { targetBgColor = { ...defaultBgColor }; } currentBgColor.r += (targetBgColor.r - currentBgColor.r) * 0.1; currentBgColor.g += (targetBgColor.g - currentBgColor.g) * 0.1; currentBgColor.b += (targetBgColor.b - currentBgColor.b) * 0.1; }
function draw() { const bgR = Math.round(currentBgColor.r); const bgG = Math.round(currentBgColor.g); const bgB = Math.round(currentBgColor.b); canvas.style.backgroundColor = `rgb(${bgR}, ${bgG}, ${bgB})`; ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.save(); let shakeX = 0; let shakeY = 0; if (camera.shakeDuration > 0) { shakeX = (Math.random() - 0.5) * camera.shakeMagnitude; shakeY = (Math.random() - 0.5) * camera.shakeMagnitude; camera.shakeDuration--; } ctx.translate(canvas.width / 2, canvas.height / 2); ctx.scale(camera.zoom, camera.zoom); ctx.translate(-camera.x - shakeX, -camera.y - shakeY); ctx.fillStyle = '#4a4a4a'; platforms.forEach(p => { if(p.disappears && p.platformState === 'invisible') return; if(p.disappears && p.platformState === 'warning') { ctx.fillStyle = 'yellow'; } ctx.fillRect(p.x, p.y, p.width, p.height); ctx.fillStyle = '#4a4a4a'; }); particles.forEach(p => { ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, p.size, p.size); }); visualEffects.forEach(effect => { if(effect.type.includes('warning_line')) { ctx.fillStyle = 'rgba(255, 0, 0, 0.5)'; if(effect.type === 'v_warning_line') { ctx.fillRect(effect.pos, camera.y - canvas.height / 2, 4, canvas.height); } else { ctx.fillRect(camera.x - canvas.width / 2, effect.pos, canvas.width, 4); } } }); ctx.fillStyle = '#FFFFFF'; ctx.font = '40px sans-serif'; gravestones.forEach(g => { ctx.save(); if (g.facingRight) { ctx.translate(g.x + 40, g.y); ctx.scale(-1, 1); ctx.fillText('ü¶Ω', 0, 0); } else { ctx.fillText('ü¶Ω', g.x, g.y); } ctx.restore(); }); ctx.font = '50px sans-serif'; decorations.forEach(d => { ctx.fillText(d.emoji, d.x, d.y + 50); if (canEnterDoor) { ctx.font = '30px sans-serif'; ctx.fillStyle = 'yellow'; ctx.fillText('W', d.x + 10, d.y); } }); ctx.font = '30px sans-serif'; items.forEach(item => { let emoji = ''; switch(item.type) { case 'xp': emoji = 'üîÜ'; break; case 'health': emoji = 'üíä'; break; case 'star': emoji = '‚≠ê'; break; case 'boots': emoji = 'üë£'; break; case 'bolt': emoji = '‚ö°'; break; } ctx.fillText(emoji, item.x, item.y + item.height); }); enemies.forEach(enemy => { ctx.save(); ctx.font = '40px sans-serif'; let emoji = ''; switch(enemy.type) { case 'ghost': emoji = 'üëª'; break; case 'flyer': emoji = 'üëæ'; break; case 'dragon': emoji = 'üêâ'; if (enemy.facingDirection > 0) { ctx.translate(enemy.x + enemy.width, enemy.y); ctx.scale(-1, 1); ctx.fillText(emoji, 0, enemy.height); } else { ctx.fillText(emoji, enemy.x, enemy.y + enemy.height); } break; } if (enemy.type !== 'dragon') { ctx.fillText(emoji, enemy.x, enemy.y + enemy.height); } if (enemy.isWarning) { ctx.font = '20px sans-serif'; let warningX = enemy.facingDirection > 0 ? enemy.x + enemy.width : enemy.x - 25; if (enemy.type === 'dragon' && enemy.facingDirection > 0) { warningX = -25; } ctx.fillText('‚ô®Ô∏è', warningX, enemy.y + enemy.height - 15); } ctx.restore(); });
    projectiles.forEach(p => { if (p.type === 'barrel') { ctx.font = '30px sans-serif'; ctx.fillText('üì¶', p.x, p.y + p.height); } else if (p.type === 'laser') { ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(p.angle); ctx.fillStyle = 'cyan'; ctx.shadowColor = 'white'; ctx.shadowBlur = 10; ctx.fillRect(0, -p.height/2, p.width, p.height); ctx.restore();} else if (p.type === 'laser_beam') { ctx.fillStyle = 'rgba(255, 0, 0, 0.5)'; ctx.fillRect(p.x, p.y, p.width, p.height); } else if (p.type === 'mine') { ctx.font = '30px sans-serif'; if(p.countdown && Math.floor(p.countdown / 15) % 2 === 0) { ctx.filter = 'brightness(1.5)'; } ctx.fillText('üí£', p.x, p.y + p.height); ctx.filter = 'none'; if(p.countdown && p.countdown < 60) { ctx.font = '20px sans-serif'; ctx.fillStyle = 'red'; ctx.fillText('‚ÄºÔ∏è', p.x, p.y); } } else { ctx.font = '30px sans-serif'; ctx.fillStyle = 'orange'; ctx.fillText('üî•', p.x, p.y + p.height); } });
    if (isBossFightActive) { if(boss && boss.state === 'falling') { ctx.fillStyle = 'rgba(0,0,0,0.4)'; ctx.beginPath(); ctx.ellipse(boss.x + boss.width / 2, boss.groundY + boss.height, boss.width / 2.5, 10, 0, 0, 2 * Math.PI); ctx.fill(); } circularShockwaves.forEach(sw => { ctx.strokeStyle = 'cyan'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(sw.x, sw.y, sw.radius, 0, Math.PI * 2); ctx.stroke(); }); if (boss) { ctx.save(); let bossX = boss.x; let bossY = boss.y; if (boss.isVulnerable) { ctx.globalAlpha = 0.7 + Math.sin(Date.now() / 100) * 0.3; bossX += (Math.random() - 0.5) * 4; bossY += (Math.random() - 0.5) * 4; } if (boss.state === 'defeated') { ctx.globalAlpha = boss.stateTimer / 180; } if (boss.type === 'robot' && boss.state === 'aiming') { ctx.fillStyle = `rgba(255, 100, 100, ${1 - (boss.stateTimer/60)})`; ctx.beginPath(); ctx.arc(boss.x + boss.width/2, boss.y + boss.height/2, 10, 0, Math.PI * 2); ctx.fill(); } const fontSize = boss.type === 'gorilla' ? '80px' : '70px'; ctx.font = `${fontSize} sans-serif`; ctx.fillText(boss.emoji, bossX, bossY + boss.height); ctx.restore(); } }
    ctx.save(); if (player.isDying) { ctx.font = '50px sans-serif'; ctx.translate(player.x + player.width / 2, player.y + player.height / 2); ctx.rotate(player.rotation * Math.PI / 180); ctx.fillText('ü§∏', -player.width / 2, player.height / 2); } else { if (player.isImmune) { ctx.globalAlpha = (Math.sin(Date.now() / 50) + 1) / 2 * 0.5 + 0.5; if (player.powerUp === 'star') { ctx.shadowColor = 'yellow'; ctx.shadowBlur = 20; } } ctx.font = '50px sans-serif'; if (player.facingRight) { ctx.translate(player.x + player.width, player.y); ctx.scale(-1, 1); ctx.fillText('üë®‚Äçü¶º', 0, player.height); } else { ctx.fillText('üë®‚Äçü¶º', player.x, player.y + player.height); } } ctx.restore();
    ctx.restore();
    ctx.save(); if (transitionState !== 'none') { const color = transitionColor === 'white' ? '255,255,255' : '0,0,0'; ctx.fillStyle = `rgba(${color}, ${transitionAlpha})`; ctx.fillRect(0, 0, canvas.width, canvas.height); } ctx.restore();
    hudParticles.forEach(p => { ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, p.size, p.size); });
}

function drawHUD() {
    healthDisplay.innerHTML = '‚ù§Ô∏è'.repeat(player.health); xpTextDisplay.textContent = player.xp;
    if (isBossFightActive && boss) {
        bossHud.style.display = 'block';
        const healthPercent = (boss.health / boss.maxHealthForPhase) * 100;
        bossHealthBar.style.width = `${healthPercent}%`;
        const currentBossData = bossProgression[bossesDefeated];
        bossNameSpan.textContent = currentBossData.name;
        if(boss.phase === 'easy') { bossPhaseIcons.textContent = currentBossData.emoji.repeat(3); }
        else if (boss.phase === 'medium') { bossPhaseIcons.textContent = currentBossData.emoji.repeat(2); }
        else if (boss.phase === 'hard') { bossPhaseIcons.textContent = currentBossData.emoji.repeat(1); }
    } else {
        bossHud.style.display = 'none';
    }
    let powerUpHTML = ''; if (player.powerUp) { switch(player.powerUp) { case 'star': powerUpHTML = '‚≠ê'; break; case 'boots': powerUpHTML = 'üë£'; break; case 'bolt': powerUpHTML = '‚ö°'; break; } } powerUpDisplay.innerHTML = powerUpHTML; if (player.powerUpTimer > 0 && player.powerUpTimer < 300) { powerUpDisplay.classList.toggle('blinking', Math.floor(player.powerUpTimer / 30) % 2 === 0); } else { powerUpDisplay.classList.remove('blinking'); }
}

function gameLoop() { if (!gameRunning && !player.isDying) { cancelAnimationFrame(gameLoopId); return; } update(); draw(); drawHUD(); gameLoopId = requestAnimationFrame(gameLoop); }
window.addEventListener('keydown', e => { if (!gameRunning) { if (e.code === 'Digit1') { jumpToBoss(0); } if (e.code === 'Digit2') { jumpToBoss(1); } return; } if (e.code === 'KeyW' && canEnterDoor && !isBossFightActive) { startBossTransition(); return; } switch (e.code) { case 'KeyA': case 'ArrowLeft': keys.left = true; break; case 'KeyD': case 'ArrowRight': keys.right = true; break; case 'Space': if (player.coyoteTimeCounter > 0) { player.vy = JUMP_FORCE; player.onGround = false; player.coyoteTimeCounter = 0; spawnJumpParticles(player.x + player.width / 2, player.y + player.height); } else if (player.canDoubleJump && !player.doubleJumpUsed) { player.vy = JUMP_FORCE * 0.9; player.doubleJumpUsed = true; spawnJumpParticles(player.x + player.width / 2, player.y + player.height); } else { player.jumpBufferCounter = JUMP_BUFFER_FRAMES; } break; case 'KeyS': case 'ArrowDown': if (player.onGround && !isBossFightActive) { player.y += 5; player.onGround = false; } break; } });
window.addEventListener('keyup', e => { if (!gameRunning) return; switch (e.code) { case 'KeyA': case 'ArrowLeft': keys.left = false; break; case 'KeyD': case 'ArrowRight': keys.right = false; break; } });
startButton.addEventListener('click', () => { startScreen.style.display = 'none'; init(); gameRunning = true; gameLoop(); });
restartButton.addEventListener('click', () => { gameOverScreen.style.display = 'none'; init(); gameRunning = true; gameLoop(); });
window.addEventListener('resize', resizeCanvas);
resizeCanvas();
function collectItem(type) { switch (type) { case 'xp': player.xp += 5; xpShakeTimer = 20; updateBossEligibility(); break; case 'health': if (player.health < player.maxHealth) { const heartX = 15 + (player.health * 24) + 12; const heartY = 15 + 12; player.health++; spawnHudParticles(heartX, heartY, '255, 255, 0'); triggerBackgroundFlash({ r: 13, g: 50, b: 46 }, 20); } break; case 'star': case 'boots': case 'bolt': startPowerUp(type, type === 'star' ? 15*60 : type === 'boots' ? 30*60 : 25*60); triggerBackgroundFlash({ r: 30, g: 50, b: 80 }, 20); break; } }
function takeDamage(amount) { if (player.isImmune || player.isDying) return; if(isBossFightActive && boss && boss.isVulnerable) return; let finalDamage = amount; if (amount === 3 && player.health <= 3) { finalDamage = player.health - 1; } const heartX = 15 + ((player.health - 1) * 24) + 12; const heartY = 15 + 12; player.health -= finalDamage; spawnHudParticles(heartX, heartY, '255, 50, 50'); camera.shakeDuration = 20; camera.shakeMagnitude = 8; triggerBackgroundFlash({ r: 0, g: 0, b: 0 }, 15); if (player.health <= 0) { player.health = 0; startDeathSequence(); } else { player.isImmune = true; setTimeout(() => { if (player.powerUp !== 'star') { player.isImmune = false; } }, 2000); } }
function startPowerUp(type, duration) { endPowerUp(); player.powerUp = type; player.powerUpTimer = duration; switch(type) { case 'star': player.isImmune = true; break; case 'boots': player.canDoubleJump = true; break; case 'bolt': player.speedMultiplier = 1.5; break; } }
function endPowerUp() { if (!player.powerUp) return; switch(player.powerUp) { case 'star': player.isImmune = false; break; case 'boots': player.canDoubleJump = false; break; case 'bolt': player.speedMultiplier = 1; break; } player.powerUp = null; player.powerUpTimer = 0; }
function startDeathSequence() { if (player.isDying) return; player.isDying = true; player.vy = JUMP_FORCE * 0.8; const gravestoneX = player.x; const gravestoneY = player.y + player.height - 20; gravestones.push({ x: gravestoneX, y: gravestoneY, facingRight: player.facingRight }); spawnHudParticles(gravestoneX, gravestoneY, '255, 50, 50'); targetBgColor = { r: 0, g: 0, b: 0 }; }
function showGameOverScreen() { if (!gameRunning && !player.isDying) return; gameRunning = false; player.isDying = false; cancelAnimationFrame(gameLoopId); if (player.xp > savedData.highScore) { savedData.highScore = player.xp; saveGame(); } finalScoreDisplay.textContent = `Sua pontua√ß√£o final: ${player.xp} üîÜ`; finalHighScoreDisplay.textContent = `High Score: ${savedData.highScore}`; bossHud.style.display = 'none'; gameOverScreen.style.display = 'flex'; }
function triggerBackgroundFlash(color, duration) { targetBgColor = color; bgFlashTimer = duration; }
function triggerKillEffects() { camera.shakeDuration = 10; camera.shakeMagnitude = 4; camera.targetZoom = 1.15; camera.zoomOverrideTimer = 15; }
function updatePowerUp() { if (player.powerUpTimer > 0) { player.powerUpTimer--; if (player.powerUpTimer <= 0) { endPowerUp(); } } }
function updateEnemies() { enemies.forEach(enemy => { switch(enemy.type) { case 'ghost': enemy.x += enemy.vx; if (enemy.platform && (enemy.x < enemy.platform.x || enemy.x + enemy.width > enemy.platform.x + enemy.platform.width)) { enemy.vx *= -1; } break; case 'flyer': let targetX = player.x; enemy.x += (targetX - enemy.x) * 0.01; enemy.y = enemy.initialY + Math.sin(Date.now() / 500) * 20; break; case 'dragon': enemy.facingDirection = (player.x < enemy.x) ? -1 : 1; if (enemy.shootCooldown > 0) { enemy.shootCooldown--; enemy.isWarning = enemy.shootCooldown < 60; } else { projectiles.push({ x: enemy.x + (enemy.facingDirection > 0 ? enemy.width : 0), y: enemy.y + enemy.height / 2, width: 20, height: 10, vx: 8 * enemy.facingDirection, type: 'fireball' }); enemy.shootCooldown = 180 + Math.random() * 60; enemy.isWarning = false; } break; } }); }
function updateCircularShockwaves() { for (let i = circularShockwaves.length - 1; i >= 0; i--) { const sw = circularShockwaves[i]; sw.radius += sw.speed; const dist = Math.abs((player.x + player.width / 2) - sw.x); if (player.onGround && Math.abs(dist - sw.radius) < (sw.speed + player.width/2) ) { takeDamage(2); circularShockwaves.splice(i,1); continue; } if (sw.radius > sw.maxRadius) { circularShockwaves.splice(i, 1); } } }
