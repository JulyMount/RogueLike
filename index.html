<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roguelike Procedural</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #1a1a1a;
            color: #fff;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
        }
        #game-container {
            position: relative;
            border: 2px solid #555;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            background-color: #0d1a2e;
            width: 100%;
            max-width: 900px;
            height: 90vh;
            max-height: 600px;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allows clicks to go through to the canvas */
            font-size: 24px;
            text-shadow: 2px 2px 4px #000;
        }
        #health {
            position: absolute;
            top: 15px;
            left: 15px;
        }
        #xp {
            position: absolute;
            top: 15px;
            right: 15px;
        }
        #power-up {
            position: absolute;
            bottom: 15px;
            left: 15px;
            font-size: 32px;
        }
        .blinking {
            animation: blink-animation 0.5s step-end infinite;
        }
        @keyframes blink-animation {
            50% {
                opacity: 0;
            }
        }
        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 10;
        }
        h1 {
            font-size: 48px;
            color: #00ffff;
        }
        p {
            font-size: 18px;
            max-width: 80%;
        }
        button {
            padding: 10px 20px;
            font-size: 20px;
            background-color: #00ffff;
            border: none;
            color: #1a1a1a;
            cursor: pointer;
            border-radius: 5px;
            margin-top: 20px;
            box-shadow: 0 0 10px #00ffff;
            transition: all 0.2s;
        }
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px #00ffff;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="hud">
        <div id="health"></div>
        <div id="xp"></div>
        <div id="power-up"></div>
    </div>
    <div id="start-screen">
        <h1>Aventura Procedural</h1>
        <p>Use <b>A</b> e <b>D</b> para mover e <b>Espa√ßo</b> para pular.</p>
        <p>Explore o mapa, colete üîÜ para XP e pise nos inimigos para derrot√°-los!</p>
        <p>üíä: Recupera Vida | ‚≠ê: Invencibilidade | üë£: Pulo Duplo | ‚ö°: Velocidade</p>
        <button id="start-button">Iniciar Jogo</button>
    </div>
    <div id="game-over-screen" style="display: none;">
        <h1>Fim de Jogo</h1>
        <p id="final-score"></p>
        <button id="restart-button">Jogar Novamente</button>
    </div>
    <canvas id="gameCanvas"></canvas>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const gameContainer = document.getElementById('game-container');

    // HUD Elements
    const healthDisplay = document.getElementById('health');
    const xpDisplay = document.getElementById('xp');
    const powerUpDisplay = document.getElementById('power-up');

    // Screen Elements
    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const startButton = document.getElementById('start-button');
    const restartButton = document.getElementById('restart-button');
    const finalScoreDisplay = document.getElementById('final-score');

    let gameLoopId;
    let gameRunning = false;

    // Game constants
    const GRAVITY = 0.6;
    const JUMP_FORCE = -14;
    const PLAYER_SPEED = 5;
    const STOMP_BOUNCE = -7;
    const TILE_SIZE = 50; // Define a standard size for room template grids

    let player, keys, camera, platforms, items, enemies, projectiles;
    let generationCursor;

    // *** NEW: Room Template Library ***
    const roomTemplates = {
        'start': {
            width: 4 * TILE_SIZE,
            platforms: [{ x: 0, y: 0, width: 4 * TILE_SIZE }],
            exit: { x: 4 * TILE_SIZE, y: 0 }
        },
        'corridor': {
            width: 8 * TILE_SIZE,
            platforms: [{ x: 0, y: 0, width: 8 * TILE_SIZE }],
            exit: { x: 8 * TILE_SIZE, y: 0 }
        },
        'gap': {
            width: 8 * TILE_SIZE,
            platforms: [
                { x: 0, y: 0, width: 3 * TILE_SIZE },
                { x: 5 * TILE_SIZE, y: 0, width: 3 * TILE_SIZE }
            ],
            exit: { x: 8 * TILE_SIZE, y: 0 }
        },
        'multi_level': {
            width: 12 * TILE_SIZE,
            platforms: [
                { x: 0, y: 0, width: 12 * TILE_SIZE }, // Bottom floor
                { x: 2 * TILE_SIZE, y: -4 * TILE_SIZE, width: 8 * TILE_SIZE } // Upper platform
            ],
            exit: { x: 12 * TILE_SIZE, y: 0 }
        },
        'climb': {
            width: 10 * TILE_SIZE,
            platforms: [
                { x: 0, y: 0, width: 3 * TILE_SIZE },
                { x: 4 * TILE_SIZE, y: -2.5 * TILE_SIZE, width: 2 * TILE_SIZE },
                { x: 7 * TILE_SIZE, y: -5 * TILE_SIZE, width: 3 * TILE_SIZE }
            ],
            exit: { x: 10 * TILE_SIZE, y: -5 * TILE_SIZE }
        },
        'shaft': {
            width: 10 * TILE_SIZE,
            platforms: [
                // Entry platform
                { x: 0, y: 0, width: 3 * TILE_SIZE },
                // Shaft platforms
                { x: 1 * TILE_SIZE, y: 2 * TILE_SIZE, width: 2 * TILE_SIZE },
                { x: 7 * TILE_SIZE, y: 4 * TILE_SIZE, width: 2 * TILE_SIZE },
                { x: 1 * TILE_SIZE, y: 6 * TILE_SIZE, width: 2 * TILE_SIZE },
                // Bottom floor
                { x: 0, y: 8 * TILE_SIZE, width: 10 * TILE_SIZE }
            ],
            exit: { x: 10 * TILE_SIZE, y: 8 * TILE_SIZE }
        }
    };

    function resizeCanvas() {
        canvas.width = gameContainer.clientWidth;
        canvas.height = gameContainer.clientHeight;
    }

    function init() {
        resizeCanvas();
        
        player = {
            x: 150,
            y: canvas.height - 200,
            width: 50,
            height: 50,
            vx: 0, vy: 0, speed: PLAYER_SPEED, onGround: false, facingRight: true,
            health: 5, maxHealth: 5, xp: 0,
            powerUp: null, powerUpTimer: 0, isImmune: false,
            canDoubleJump: false, doubleJumpUsed: false, speedMultiplier: 1,
        };

        keys = { right: false, left: false, jump: false };
        camera = { x: 0, y: 0 };
        platforms = [];
        items = [];
        enemies = [];
        projectiles = [];
        
        generationCursor = { x: 50, y: canvas.height - 100 };

        // Generate the initial world using the new room system
        stampRoom('start');
        for(let i = 0; i < 15; i++) {
             stampRoom();
        }
    }

    // --- MAP GENERATION REVAMPED ---
    function stampRoom(roomName) {
        const templateNames = Object.keys(roomTemplates).filter(name => name !== 'start');
        const chosenRoomName = roomName || templateNames[Math.floor(Math.random() * templateNames.length)];
        const template = roomTemplates[chosenRoomName];

        template.platforms.forEach(p_template => {
            const newPlatform = {
                x: generationCursor.x + p_template.x,
                y: generationCursor.y + p_template.y,
                width: p_template.width,
                height: 20
            };
            platforms.push(newPlatform);

            // Spawn items and enemies on this new platform
            if (Math.random() < 0.2) {
                spawnItem(newPlatform);
            }
            if (Math.random() < 0.25) {
                spawnEnemy(newPlatform);
            }
        });

        // Move the cursor to the exit of the stamped room
        generationCursor.x += template.exit.x;
        generationCursor.y += template.exit.y;
    }

    function spawnItem(platform) {
        const itemTypes = ['xp', 'health', 'star', 'boots', 'bolt'];
        const weights = [0.6, 0.2, 0.05, 0.075, 0.075];
        let rand = Math.random();
        let type = 'xp';

        let cumulativeWeight = 0;
        for (let i = 0; i < itemTypes.length; i++) {
            cumulativeWeight += weights[i];
            if (rand < cumulativeWeight) {
                type = itemTypes[i];
                break;
            }
        }
        
        if (type === 'health' && player.health >= player.maxHealth) type = 'xp';

        items.push({
            x: platform.x + Math.random() * (platform.width - 30),
            y: platform.y - 40,
            width: 30, height: 30, type: type
        });
    }

    function spawnEnemy(platform) {
        const enemyTypes = ['ghost', 'flyer', 'dragon'];
        const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
        const yPos = platform.y - 45;

        enemies.push({
            x: platform.x + Math.random() * (platform.width - 40),
            y: yPos,
            width: 40, height: 40, type: type,
            vx: type === 'ghost' ? (Math.random() > 0.5 ? 1 : -1) * 1.5 : 0,
            vy: 0, platform: platform, initialY: yPos,
            shootCooldown: type === 'dragon' ? 180 : 0,
            isWarning: false, facingDirection: -1
        });
    }

    // --- UPDATE LOGIC ---
    function update() {
        // Player Movement
        player.vx = 0;
        if (keys.left) { player.vx = -player.speed * player.speedMultiplier; player.facingRight = false; }
        if (keys.right) { player.vx = player.speed * player.speedMultiplier; player.facingRight = true; }
        player.x += player.vx;

        // Gravity and Vertical Movement
        player.vy += GRAVITY;
        player.y += player.vy;
        player.onGround = false;

        // Platform Collision
        const nearbyPlatforms = platforms.filter(p => 
            p.x < player.x + canvas.width / 2 && p.x + p.width > player.x - canvas.width / 2
        );

        nearbyPlatforms.forEach(platform => {
            if (player.x + player.width > platform.x && player.x < platform.x + platform.width &&
                player.y + player.height > platform.y && player.y < platform.y + platform.height) {
                if (player.vy >= 0 && (player.y + player.height - player.vy) <= platform.y) {
                    player.y = platform.y - player.height;
                    player.vy = 0;
                    player.onGround = true;
                    player.doubleJumpUsed = false;
                }
            }
        });
        
        // Item Collision
        items.forEach((item, index) => {
            if (player.x < item.x + item.width && player.x + player.width > item.x &&
                player.y < item.y + item.height && player.y + player.height > item.y) {
                collectItem(item.type);
                items.splice(index, 1);
            }
        });

        // Enemy Collision
        enemies.forEach((enemy, index) => {
            if (player.x < enemy.x + enemy.width && player.x + player.width > enemy.x &&
                player.y < enemy.y + enemy.height && player.y + player.height > enemy.y) {
                if (player.vy > 0 && (player.y + player.height - player.vy) <= enemy.y + 10) {
                    enemies.splice(index, 1);
                    player.vy = STOMP_BOUNCE;
                    player.xp += 10;
                } else if (player.isImmune) {
                    enemies.splice(index, 1);
                    player.xp += 10;
                } else {
                    takeDamage(enemy.type === 'ghost' ? 1 : 2);
                }
            }
        });

        // Projectile Collision
        projectiles.forEach((p, index) => {
            if (player.x < p.x + p.width && player.x + player.width > p.x &&
                player.y < p.y + p.height && player.y + player.height > p.y) {
                if (!player.isImmune) { takeDamage(3); }
                projectiles.splice(index, 1);
            }
        });

        // Update Game Objects
        updateEnemies();
        updateProjectiles();
        updatePowerUp();

        // Update Camera
        camera.x += (player.x - camera.x - canvas.width / 3) * 0.1;
        camera.y += (player.y - camera.y - canvas.height / 2) * 0.1;
        
        // Generate new chunks if needed
        if (player.x > generationCursor.x - canvas.width * 2) {
            stampRoom();
        }

        // Check for falling out of world
        if (player.y > camera.y + canvas.height + 400) { gameOver(); }
    }

    function updateEnemies() {
        enemies.forEach(enemy => {
            switch(enemy.type) {
                case 'ghost':
                    enemy.x += enemy.vx;
                    if (enemy.x < enemy.platform.x || enemy.x + enemy.width > enemy.platform.x + enemy.platform.width) {
                        enemy.vx *= -1;
                    }
                    break;
                case 'flyer':
                    let targetX = player.x;
                    enemy.x += (targetX - enemy.x) * 0.01;
                    enemy.y = enemy.initialY + Math.sin(Date.now() / 500) * 20;
                    break;
                case 'dragon':
                    enemy.facingDirection = (player.x < enemy.x) ? -1 : 1;
                    if (enemy.shootCooldown > 0) {
                        enemy.shootCooldown--;
                        enemy.isWarning = enemy.shootCooldown < 60;
                    } else {
                        projectiles.push({
                            x: enemy.x + (enemy.facingDirection > 0 ? enemy.width : 0),
                            y: enemy.y + enemy.height / 2,
                            width: 20, height: 10, vx: 8 * enemy.facingDirection
                        });
                        enemy.shootCooldown = 180 + Math.random() * 60;
                        enemy.isWarning = false;
                    }
                    break;
            }
        });
    }
    
    function updateProjectiles() {
        projectiles.forEach((p, index) => {
            p.x += p.vx;
            if (p.x < camera.x - 50 || p.x > camera.x + canvas.width + 50) {
                projectiles.splice(index, 1);
            }
        });
    }

    function updatePowerUp() {
        if (player.powerUpTimer > 0) {
            player.powerUpTimer--;
            if (player.powerUpTimer <= 0) {
                endPowerUp();
            }
        }
    }

    function collectItem(type) {
        switch (type) {
            case 'xp': player.xp += 5; break;
            case 'health': if (player.health < player.maxHealth) { player.health++; } break;
            case 'star': startPowerUp('star', 15 * 60); break;
            case 'boots': startPowerUp('boots', 30 * 60); break;
            case 'bolt': startPowerUp('bolt', 25 * 60); break;
        }
    }
    
    function takeDamage(amount) {
        if (player.isImmune) return;
        
        let finalDamage = amount;
        if (amount === 3 && player.health <= 3) { finalDamage = player.health - 1; }

        player.health -= finalDamage;
        if (player.health <= 0) {
            player.health = 0;
            gameOver();
        } else {
            player.isImmune = true;
            setTimeout(() => {
                if (player.powerUp !== 'star') { player.isImmune = false; }
            }, 2000);
        }
    }

    function startPowerUp(type, duration) {
        endPowerUp();
        player.powerUp = type;
        player.powerUpTimer = duration;
        switch(type) {
            case 'star': player.isImmune = true; break;
            case 'boots': player.canDoubleJump = true; break;
            case 'bolt': player.speedMultiplier = 1.5; break;
        }
    }

    function endPowerUp() {
        if (!player.powerUp) return;
        switch(player.powerUp) {
            case 'star': player.isImmune = false; break;
            case 'boots': player.canDoubleJump = false; break;
            case 'bolt': player.speedMultiplier = 1; break;
        }
        player.powerUp = null;
        player.powerUpTimer = 0;
    }

    function gameOver() {
        gameRunning = false;
        cancelAnimationFrame(gameLoopId);
        finalScoreDisplay.textContent = `Sua pontua√ß√£o final: ${player.xp} ÔøΩ`;
        gameOverScreen.style.display = 'flex';
    }

    // --- DRAW LOGIC ---
    function draw() {
        ctx.fillStyle = '#0d1a2e';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.save();
        ctx.translate(-camera.x, -camera.y);

        // Draw platforms
        ctx.fillStyle = '#4a4a4a';
        platforms.forEach(p => { ctx.fillRect(p.x, p.y, p.width, p.height); });

        // Draw items
        ctx.font = '30px sans-serif';
        items.forEach(item => {
            let emoji = '';
            switch(item.type) {
                case 'xp': emoji = 'üîÜ'; break;
                case 'health': emoji = 'üíä'; break;
                case 'star': emoji = '‚≠ê'; break;
                case 'boots': emoji = 'üë£'; break;
                case 'bolt': emoji = '‚ö°'; break;
            }
            ctx.fillText(emoji, item.x, item.y + item.height);
        });
        
        // Draw enemies
        enemies.forEach(enemy => {
            ctx.save();
            ctx.font = '40px sans-serif';
            let emoji = '';
            switch(enemy.type) {
                case 'ghost': emoji = 'üëª'; break;
                case 'flyer': emoji = 'üëæ'; break;
                case 'dragon': 
                    emoji = 'üêâ';
                    if (enemy.facingDirection > 0) { // Facing right
                        ctx.translate(enemy.x + enemy.width, enemy.y);
                        ctx.scale(-1, 1);
                        ctx.fillText(emoji, 0, enemy.height);
                    } else { // Facing left
                        ctx.fillText(emoji, enemy.x, enemy.y + enemy.height);
                    }
                    break;
            }
            
            if (enemy.type !== 'dragon') {
                ctx.fillText(emoji, enemy.x, enemy.y + enemy.height);
            }

            if (enemy.isWarning) {
                ctx.font = '20px sans-serif';
                let warningX = enemy.facingDirection > 0 ? enemy.x + enemy.width : enemy.x - 25;
                if (enemy.type === 'dragon' && enemy.facingDirection > 0) {
                    warningX = -25;
                }
                ctx.fillText('‚ô®Ô∏è', warningX, enemy.y + enemy.height - 15);
            }
            ctx.restore();
        });
        
        // Draw projectiles
        ctx.font = '30px sans-serif';
        ctx.fillStyle = 'orange';
        projectiles.forEach(p => { ctx.fillText('üî•', p.x, p.y + p.height); });

        // Draw player
        ctx.save();
        if (player.isImmune) {
            ctx.globalAlpha = (Math.sin(Date.now() / 50) + 1) / 2 * 0.5 + 0.5;
            if (player.powerUp === 'star') { ctx.shadowColor = 'yellow'; ctx.shadowBlur = 20; }
        }
        
        ctx.font = '50px sans-serif';
        if (player.facingRight) {
            ctx.translate(player.x + player.width, player.y);
            ctx.scale(-1, 1);
            ctx.fillText('üë®‚Äçü¶º', 0, player.height);
        } else {
            ctx.fillText('üë®‚Äçü¶º', player.x, player.y + player.height);
        }
        ctx.restore();

        ctx.restore();
    }
    
    function drawHUD() {
        healthDisplay.innerHTML = '‚ù§Ô∏è'.repeat(player.health);
        xpDisplay.innerHTML = `üîÜ ${player.xp}`;

        let powerUpHTML = '';
        if (player.powerUp) {
            switch(player.powerUp) {
                case 'star': powerUpHTML = '‚≠ê'; break;
                case 'boots': powerUpHTML = 'üë£'; break;
                case 'bolt': powerUpHTML = '‚ö°'; break;
            }
        }
        powerUpDisplay.innerHTML = powerUpHTML;
        
        if (player.powerUpTimer > 0 && player.powerUpTimer < 300) {
            powerUpDisplay.classList.toggle('blinking', Math.floor(player.powerUpTimer / 30) % 2 === 0);
        } else {
            powerUpDisplay.classList.remove('blinking');
        }
    }

    // --- MAIN GAME LOOP ---
    function gameLoop() {
        if (!gameRunning) return;
        update();
        draw();
        drawHUD();
        gameLoopId = requestAnimationFrame(gameLoop);
    }

    // --- EVENT LISTENERS ---
    window.addEventListener('keydown', e => {
        if (!gameRunning) return;
        switch (e.code) {
            case 'KeyA': case 'ArrowLeft': keys.left = true; break;
            case 'KeyD': case 'ArrowRight': keys.right = true; break;
            case 'Space':
                if (player.onGround) {
                    player.vy = JUMP_FORCE;
                    player.onGround = false;
                } else if (player.canDoubleJump && !player.doubleJumpUsed) {
                    player.vy = JUMP_FORCE * 0.9;
                    player.doubleJumpUsed = true;
                }
                break;
        }
    });

    window.addEventListener('keyup', e => {
        if (!gameRunning) return;
        switch (e.code) {
            case 'KeyA': case 'ArrowLeft': keys.left = false; break;
            case 'KeyD': case 'ArrowRight': keys.right = false; break;
        }
    });

    startButton.addEventListener('click', () => {
        startScreen.style.display = 'none';
        init();
        gameRunning = true;
        gameLoop();
    });



    restartButton.addEventListener('click', () => {
        gameOverScreen.style.display = 'none';
        init();
        gameRunning = true;
        gameLoop();
    });

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

</script>
</body>
</html>
ÔøΩ