<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="https://www.seton.com.br/media/catalog/product/cache/1/image/380x380/9df78eab33525d08d6e5fb8d27136e95/i/m/image-3-compressed_1_1.jpg">
    <title>Rogue Wheels</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #1a1a1a;
            color: #fff;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
        }
        #game-container {
            position: relative;
            border: 2px solid #555;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            /* The background color will now be controlled by JavaScript */
            width: 100%;
            max-width: 900px;
            height: 90vh;
            max-height: 600px;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allows clicks to go through to the canvas */
            font-size: 24px;
            text-shadow: 2px 2px 4px #000;
        }
        #health {
            position: absolute;
            top: 15px;
            left: 15px;
        }
        #xp {
            position: absolute;
            top: 15px;
            right: 15px;
        }
        /* Style for the XP text specifically */
        #xp-text {
             display: inline-block; /* Needed for transform to work correctly */
             transition: transform 0.1s, color 0.1s, font-weight 0.1s;
        }
        #power-up {
            position: absolute;
            bottom: 15px;
            left: 15px;
            font-size: 32px;
        }
        .blinking {
            animation: blink-animation 0.5s step-end infinite;
        }
        @keyframes blink-animation {
            50% {
                opacity: 0;
            }
        }
        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 10;
        }
        h1 {
            font-size: 48px;
            color: #00ffff;
        }
        p {
            font-size: 18px;
            max-width: 80%;
        }
        button {
            padding: 10px 20px;
            font-size: 20px;
            background-color: #00ffff;
            border: none;
            color: #1a1a1a;
            cursor: pointer;
            border-radius: 5px;
            margin-top: 20px;
            box-shadow: 0 0 10px #00ffff;
            transition: all 0.2s;
        }
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px #00ffff;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="hud">
        <div id="health"></div>
        <div id="xp">
            <span>üîÜ </span><span id="xp-text">0</span>
        </div>
        <div id="power-up"></div>
    </div>
    <div id="start-screen">
        <h1>Aventura Procedural</h1>
        <p>Use <b>A/D</b> para mover, <b>Espa√ßo</b> para pular e <b>S</b> para descer.</p>
        <p>Explore o mapa, colete üîÜ para XP e pise nos inimigos para derrot√°-los!</p>
        <p>üíä: Recupera Vida | ‚≠ê: Invencibilidade | üë£: Pulo Duplo | ‚ö°: Velocidade</p>
        <button id="start-button">Iniciar Jogo</button>
    </div>
    <div id="game-over-screen" style="display: none;">
        <h1>Fim de Jogo</h1>
        <p id="final-score"></p>
        <button id="restart-button">Jogar Novamente</button>
    </div>
    <canvas id="gameCanvas"></canvas>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const gameContainer = document.getElementById('game-container');

    // HUD Elements
    const healthDisplay = document.getElementById('health');
    const xpTextDisplay = document.getElementById('xp-text');
    const powerUpDisplay = document.getElementById('power-up');

    // Screen Elements
    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const startButton = document.getElementById('start-button');
    const restartButton = document.getElementById('restart-button');
    const finalScoreDisplay = document.getElementById('final-score');

    let gameLoopId;
    let gameRunning = false;

    // Game constants
    const GRAVITY = 0.6;
    const JUMP_FORCE = -14;
    const PLAYER_SPEED = 5;
    const STOMP_BOUNCE = -7;
    const TILE_SIZE = 50;
    const COYOTE_TIME_FRAMES = 8;
    const JUMP_BUFFER_FRAMES = 8;
    const MAX_FALL_SPEED = 18;

    let player, keys, camera, platforms, items, enemies, projectiles, particles, hudParticles, gravestones;
    let generationCursor;
    let xpShakeTimer = 0;

    // Background color system variables
    const defaultBgColor = { r: 13, g: 26, b: 46 };
    let currentBgColor = { ...defaultBgColor };
    let targetBgColor = { ...defaultBgColor };
    let bgFlashTimer = 0;

    // Room Template Library
    const roomTemplates = {
        'start': {
            width: 4 * TILE_SIZE,
            platforms: [{ x: 0, y: 0, width: 4 * TILE_SIZE }],
            exit: { x: 4 * TILE_SIZE, y: 0 }
        },
        'corridor': {
            width: 8 * TILE_SIZE,
            platforms: [{ x: 0, y: 0, width: 8 * TILE_SIZE }],
            exit: { x: 8 * TILE_SIZE, y: 0 }
        },
        'gap': {
            width: 8 * TILE_SIZE,
            platforms: [
                { x: 0, y: 0, width: 3 * TILE_SIZE },
                { x: 5 * TILE_SIZE, y: 0, width: 3 * TILE_SIZE }
            ],
            exit: { x: 8 * TILE_SIZE, y: 0 }
        },
        'multi_level': {
            width: 12 * TILE_SIZE,
            platforms: [
                { x: 0, y: 0, width: 12 * TILE_SIZE },
                { x: 2 * TILE_SIZE, y: -4 * TILE_SIZE, width: 8 * TILE_SIZE }
            ],
            exit: { x: 12 * TILE_SIZE, y: 0 }
        },
        'climb': {
            width: 10 * TILE_SIZE,
            platforms: [
                { x: 0, y: 0, width: 3 * TILE_SIZE },
                { x: 4 * TILE_SIZE, y: -2.5 * TILE_SIZE, width: 2 * TILE_SIZE },
                { x: 7 * TILE_SIZE, y: -5 * TILE_SIZE, width: 3 * TILE_SIZE }
            ],
            exit: { x: 10 * TILE_SIZE, y: -5 * TILE_SIZE }
        },
        'shaft': {
            width: 10 * TILE_SIZE,
            platforms: [
                { x: 0, y: 0, width: 3 * TILE_SIZE },
                { x: 1 * TILE_SIZE, y: 2 * TILE_SIZE, width: 2 * TILE_SIZE },
                { x: 7 * TILE_SIZE, y: 4 * TILE_SIZE, width: 2 * TILE_SIZE },
                { x: 1 * TILE_SIZE, y: 6 * TILE_SIZE, width: 2 * TILE_SIZE },
                { x: 0, y: 8 * TILE_SIZE, width: 10 * TILE_SIZE }
            ],
            exit: { x: 10 * TILE_SIZE, y: 8 * TILE_SIZE }
        },
        'staircase_down': {
            width: 12 * TILE_SIZE,
            platforms: [
                { x: 0, y: 0, width: 3 * TILE_SIZE },
                { x: 3 * TILE_SIZE, y: 1.5 * TILE_SIZE, width: 3 * TILE_SIZE },
                { x: 6 * TILE_SIZE, y: 3 * TILE_SIZE, width: 3 * TILE_SIZE },
                { x: 9 * TILE_SIZE, y: 4.5 * TILE_SIZE, width: 3 * TILE_SIZE }
            ],
            exit: { x: 12 * TILE_SIZE, y: 4.5 * TILE_SIZE }
        },
        'pillar_room': {
            width: 15 * TILE_SIZE,
            platforms: [
                { x: 0, y: 0, width: 15 * TILE_SIZE },
                { x: 3 * TILE_SIZE, y: -3 * TILE_SIZE, width: 1.5 * TILE_SIZE },
                { x: 8 * TILE_SIZE, y: -4 * TILE_SIZE, width: 1.5 * TILE_SIZE },
                { x: 12 * TILE_SIZE, y: -2 * TILE_SIZE, width: 1.5 * TILE_SIZE }
            ],
            exit: { x: 15 * TILE_SIZE, y: 0 }
        },
        'chain_jump': {
            width: 14 * TILE_SIZE,
            platforms: [
                { x: 0, y: 0, width: 3 * TILE_SIZE },
                { x: 4.5 * TILE_SIZE, y: -0.5 * TILE_SIZE, width: 1 * TILE_SIZE },
                { x: 7 * TILE_SIZE, y: 0 * TILE_SIZE, width: 1 * TILE_SIZE },
                { x: 9.5 * TILE_SIZE, y: -0.5 * TILE_SIZE, width: 1 * TILE_SIZE },
                { x: 11 * TILE_SIZE, y: 0, width: 3 * TILE_SIZE }
            ],
            exit: { x: 14 * TILE_SIZE, y: 0 }
        }
    };

    function resizeCanvas() {
        canvas.width = gameContainer.clientWidth;
        canvas.height = gameContainer.clientHeight;
    }

    function init() {
        resizeCanvas();
        
        player = {
            x: 150,
            y: canvas.height - 200,
            width: 50, height: 50,
            vx: 0, vy: 0, speed: PLAYER_SPEED, onGround: false, facingRight: true,
            health: 5, maxHealth: 5, xp: 0,
            powerUp: null, powerUpTimer: 0, isImmune: false,
            canDoubleJump: false, doubleJumpUsed: false, speedMultiplier: 1,
            isDying: false, rotation: 0,
            coyoteTimeCounter: 0,
            jumpBufferCounter: 0
        };

        keys = { right: false, left: false, jump: false };
        camera = { 
            x: player.x,
            y: player.y,
            zoom: 1.0, targetZoom: 1.0,
            shakeDuration: 0, shakeMagnitude: 0,
            zoomOverrideTimer: 0
        };
        platforms = [];
        items = [];
        enemies = [];
        projectiles = [];
        particles = [];
        hudParticles = [];
        gravestones = [];
        
        generationCursor = { x: 50, y: canvas.height - 100 };

        stampRoom('start');
        for(let i = 0; i < 15; i++) {
             stampRoom();
        }
    }

    // --- MAP GENERATION REVAMPED ---
    function stampRoom(roomName) {
        const templateNames = Object.keys(roomTemplates).filter(name => name !== 'start');
        const chosenRoomName = roomName || templateNames[Math.floor(Math.random() * templateNames.length)];
        const template = roomTemplates[chosenRoomName];

        template.platforms.forEach(p_template => {
            const newPlatform = {
                x: generationCursor.x + p_template.x,
                y: generationCursor.y + p_template.y,
                width: p_template.width,
                height: 20
            };
            platforms.push(newPlatform);

            if (Math.random() < 0.2) spawnItem(newPlatform);
            if (Math.random() < 0.25) spawnEnemy(newPlatform);
        });

        generationCursor.x += template.exit.x;
        generationCursor.y += template.exit.y;
    }

    function spawnItem(platform) {
        const itemTypes = ['xp', 'health', 'star', 'boots', 'bolt'];
        const weights = [0.6, 0.2, 0.05, 0.075, 0.075];
        let rand = Math.random();
        let type = 'xp';

        let cumulativeWeight = 0;
        for (let i = 0; i < itemTypes.length; i++) {
            cumulativeWeight += weights[i];
            if (rand < cumulativeWeight) {
                type = itemTypes[i];
                break;
            }
        }
        
        if (type === 'health' && player.health >= player.maxHealth) type = 'xp';

        items.push({
            x: platform.x + Math.random() * (platform.width - 30),
            y: platform.y - 40,
            width: 30, height: 30, type: type
        });
    }

    function spawnEnemy(platform) {
        let type = ['ghost', 'flyer', 'dragon'][Math.floor(Math.random() * 3)];
        
        if (type === 'dragon' && platform.width < TILE_SIZE * 2.5) {
            type = 'ghost';
        }

        const yPos = platform.y - 45;

        enemies.push({
            x: platform.x + Math.random() * (platform.width - 40),
            y: yPos,
            width: 40, height: 40, type: type,
            vx: type === 'ghost' ? (Math.random() > 0.5 ? 1 : -1) * 1.5 : 0,
            vy: 0, platform: platform, initialY: yPos,
            shootCooldown: type === 'dragon' ? 180 : 0,
            isWarning: false, facingDirection: -1
        });
    }

    // --- PARTICLE SYSTEMS ---
    function spawnJumpParticles(x, y) {
        for (let i = 0; i < 8; i++) {
            particles.push({
                x: x, y: y,
                vx: (Math.random() - 0.5) * 4, vy: (Math.random() * -3) - 1,
                size: Math.random() * 5 + 3, life: 30 + Math.random() * 20,
                color: `rgba(200, 200, 200, ${Math.random() * 0.5 + 0.3})`
            });
        }
    }
    
    function spawnExplosionParticles(x, y) {
        for (let i = 0; i < 20; i++) {
            particles.push({
                x: x, y: y,
                vx: (Math.random() - 0.5) * 6, vy: (Math.random() - 0.5) * 6,
                size: Math.random() * 8 + 4, life: 25 + Math.random() * 15,
                color: `rgba(50, 50, 50, ${Math.random() * 0.5 + 0.4})`
            });
        }
    }

    function spawnSpeedParticles(x, y) {
        particles.push({
            x: x,
            y: y + (Math.random() - 0.5) * player.height * 0.8,
            vx: -player.vx * 0.2,
            vy: (Math.random() - 0.5) * 2,
            size: Math.random() * 4 + 2,
            life: 15 + Math.random() * 10,
            color: `rgba(255, 220, 0, ${Math.random() * 0.5 + 0.5})`
        });
    }

    function spawnHudParticles(x, y, color) {
        for (let i = 0; i < 15; i++) {
            hudParticles.push({
                x: x, y: y,
                vx: (Math.random() - 0.5) * 5, vy: (Math.random() - 0.5) * 5,
                size: Math.random() * 4 + 2, life: 40 + Math.random() * 20,
                color: `rgba(${color}, ${Math.random() * 0.6 + 0.4})`
            });
        }
    }

    function updateParticles(particleArray) {
        for (let i = particleArray.length - 1; i >= 0; i--) {
            const p = particleArray[i];
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.1; 
            p.life--;
            p.size *= 0.98;

            if (p.life <= 0 || p.size < 0.5) {
                particleArray.splice(i, 1);
            }
        }
    }


    // --- UPDATE LOGIC ---
    function update() {
        if (player.isDying) {
            player.vy += GRAVITY * 0.8;
            player.y += player.vy;
            player.rotation += 15;
            
            if (player.y > camera.y + canvas.height + 100) {
                showGameOverScreen();
            }
            updateParticles(particles);
            updateParticles(hudParticles);
            return;
        }

        // Player Movement
        player.vx = 0;
        if (keys.left) { player.vx = -player.speed * player.speedMultiplier; player.facingRight = false; }
        if (keys.right) { player.vx = player.speed * player.speedMultiplier; player.facingRight = true; }
        player.x += player.vx;

        // Gravity and Vertical Movement
        player.vy += GRAVITY;
        player.vy = Math.min(player.vy, MAX_FALL_SPEED);
        player.y += player.vy;
        
        const wasOnGround = player.onGround;
        player.onGround = false;

        // Platform Collision
        const nearbyPlatforms = platforms.filter(p => 
            p.x < player.x + canvas.width && p.x + p.width > player.x - canvas.width
        );

        nearbyPlatforms.forEach(platform => {
            if (player.x + player.width > platform.x && 
                player.x < platform.x + platform.width &&
                player.vy >= 0) {
                
                const previousPlayerBottom = (player.y + player.height) - player.vy;
                const currentPlayerBottom = player.y + player.height;

                if (previousPlayerBottom <= platform.y && currentPlayerBottom >= platform.y) {
                    player.y = platform.y - player.height;
                    player.vy = 0;
                    player.onGround = true;
                    player.doubleJumpUsed = false;
                }
            }
        });

        // Coyote Time & Jump Buffer Logic
        if (player.onGround) {
            player.coyoteTimeCounter = COYOTE_TIME_FRAMES;
        } else {
            if (wasOnGround) {
                player.coyoteTimeCounter = COYOTE_TIME_FRAMES;
            } else {
                player.coyoteTimeCounter--;
            }
        }

        if (player.jumpBufferCounter > 0) {
            if (player.onGround) {
                player.vy = JUMP_FORCE;
                player.onGround = false;
                spawnJumpParticles(player.x + player.width / 2, player.y + player.height);
                player.jumpBufferCounter = 0;
            } else {
                player.jumpBufferCounter--;
            }
        }
        
        // Item Collision
        items.forEach((item, index) => {
            if (player.x < item.x + item.width && player.x + player.width > item.x &&
                player.y < item.y + item.height && player.y + player.height > item.y) {
                collectItem(item.type);
                items.splice(index, 1);
            }
        });

        // Enemy Collision
        enemies.forEach((enemy, index) => {
            if (player.x < enemy.x + enemy.width && player.x + player.width > enemy.x &&
                player.y < enemy.y + enemy.height && player.y + player.height > enemy.y) {
                
                const isStomp = player.vy > 0 && (player.y + player.height - player.vy) <= enemy.y + 10;
                const isStarKill = player.isImmune && player.powerUp === 'star';

                if (isStomp || isStarKill) {
                    let isOverVoid = true;
                    const checkDistance = 50;
                    for (const p of platforms) {
                        if (enemy.x + enemy.width > p.x && 
                            enemy.x < p.x + p.width &&
                            enemy.y < p.y && p.y < enemy.y + enemy.height + checkDistance) {
                            isOverVoid = false;
                            break;
                        }
                    }

                    if (isOverVoid) {
                        let closestPlatformAbove = null;
                        let minDistance = Infinity;
                        for (const p of platforms) {
                            if (enemy.x + enemy.width > p.x && 
                                enemy.x < p.x + p.width &&
                                p.y < enemy.y) {
                                const distance = enemy.y - (p.y + p.height);
                                if (distance < minDistance) {
                                    minDistance = distance;
                                    closestPlatformAbove = p;
                                }
                            }
                        }
                        
                        if (closestPlatformAbove) {
                            const jumpHeight = minDistance + player.height;
                            player.vy = -Math.sqrt(2 * GRAVITY * jumpHeight) * 1.1;
                        } else {
                            player.vy = JUMP_FORCE * 1.2;
                        }
                    } else if (isStomp) { // Only give stomp bounce if it was a stomp
                        player.vy = STOMP_BOUNCE;
                    }
                    
                    spawnExplosionParticles(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
                    enemies.splice(index, 1);
                    player.xp += 10;
                    xpShakeTimer = 20;
                    triggerKillEffects();
                } else if (!player.isImmune) {
                    takeDamage(enemy.type === 'ghost' ? 1 : 2);
                }
            }
        });

        // Projectile Collision
        projectiles.forEach((p, index) => {
            if (player.x < p.x + p.width && player.x + player.width > p.x &&
                player.y < p.y + p.height && player.y + player.height > p.y) {
                if (!player.isImmune) { takeDamage(3); }
                projectiles.splice(index, 1);
            }
        });

        // Update Game Objects
        updateEnemies();
        updateProjectiles();
        updatePowerUp();
        updateParticles(particles);
        updateParticles(hudParticles);

        if (player.powerUp === 'bolt' && player.vx !== 0) {
            if (Math.random() < 0.7) {
                 spawnSpeedParticles(player.x + player.width / 2, player.y + player.height / 2);
            }
        }

        // Update Camera position and zoom
        if (camera.zoomOverrideTimer > 0) {
            camera.zoomOverrideTimer--;
        } else {
            if (player.vx !== 0) {
                camera.targetZoom = 1.1;
            } else {
                camera.targetZoom = 1.0;
            }
        }
        camera.zoom += (camera.targetZoom - camera.zoom) * 0.04;

        camera.x += (player.x - camera.x) * 0.05;
        camera.y += (player.y - camera.y) * 0.05;
        
        // Update XP Shake
        if (xpShakeTimer > 0) {
            const shakeX = (Math.random() - 0.5) * 8; 
            const shakeY = (Math.random() - 0.5) * 8;
            const scale = 1.5;
            const rotation = 10;
            xpTextDisplay.style.transform = `translate(${shakeX}px, ${shakeY}px) scale(${scale}) rotate(${rotation}deg)`;
            xpTextDisplay.style.color = 'yellow';
            xpTextDisplay.style.fontWeight = 'bold';
            xpShakeTimer--;
        } else {
            xpTextDisplay.style.transform = 'translate(0, 0) scale(1) rotate(0deg)';
            xpTextDisplay.style.color = 'white';
            xpTextDisplay.style.fontWeight = 'normal';
        }

        // Despawn off-screen objects to prevent freezing
        const despawnX = camera.x - canvas.width;
        platforms = platforms.filter(p => p.x + p.width > despawnX);
        items = items.filter(i => i.x + i.width > despawnX);
        enemies = enemies.filter(e => e.x + e.width > despawnX);
        gravestones = gravestones.filter(g => g.x > despawnX);

        // Generate new chunks if needed
        if (player.x > generationCursor.x - canvas.width * 2) {
            stampRoom();
        }

        // Check for falling out of world
        const bottomOfScreen = camera.y + (canvas.height / 2) / camera.zoom;
        if (player.y > bottomOfScreen) { 
            startDeathSequence(); 
        }

        // Update background color
        if (bgFlashTimer > 0) {
            bgFlashTimer--;
        } else {
            targetBgColor = { ...defaultBgColor };
        }
        currentBgColor.r += (targetBgColor.r - currentBgColor.r) * 0.1;
        currentBgColor.g += (targetBgColor.g - currentBgColor.g) * 0.1;
        currentBgColor.b += (targetBgColor.b - currentBgColor.b) * 0.1;
    }

    function updateEnemies() {
        enemies.forEach(enemy => {
            switch(enemy.type) {
                case 'ghost':
                    enemy.x += enemy.vx;
                    if (enemy.x < enemy.platform.x || enemy.x + enemy.width > enemy.platform.x + enemy.platform.width) {
                        enemy.vx *= -1;
                    }
                    break;
                case 'flyer':
                    let targetX = player.x;
                    enemy.x += (targetX - enemy.x) * 0.01;
                    enemy.y = enemy.initialY + Math.sin(Date.now() / 500) * 20;
                    break;
                case 'dragon':
                    enemy.facingDirection = (player.x < enemy.x) ? -1 : 1;
                    if (enemy.shootCooldown > 0) {
                        enemy.shootCooldown--;
                        enemy.isWarning = enemy.shootCooldown < 60;
                    } else {
                        projectiles.push({
                            x: enemy.x + (enemy.facingDirection > 0 ? enemy.width : 0),
                            y: enemy.y + enemy.height / 2,
                            width: 20, height: 10, vx: 8 * enemy.facingDirection
                        });
                        enemy.shootCooldown = 180 + Math.random() * 60;
                        enemy.isWarning = false;
                    }
                    break;
            }
        });
    }
    
    function updateProjectiles() {
        projectiles.forEach((p, index) => {
            p.x += p.vx;
            if (p.x < camera.x - 50 || p.x > camera.x + canvas.width + 50) {
                projectiles.splice(index, 1);
            }
        });
    }

    function updatePowerUp() {
        if (player.powerUpTimer > 0) {
            player.powerUpTimer--;
            if (player.powerUpTimer <= 0) {
                endPowerUp();
            }
        }
    }

    function triggerBackgroundFlash(color, duration) {
        targetBgColor = color;
        bgFlashTimer = duration;
    }

    function triggerKillEffects() {
        camera.shakeDuration = 10;
        camera.shakeMagnitude = 4;
        camera.targetZoom = 1.15;
        camera.zoomOverrideTimer = 15;
    }

    function collectItem(type) {
        switch (type) {
            case 'xp': 
                player.xp += 5; 
                xpShakeTimer = 20;
                break;
            case 'health': 
                if (player.health < player.maxHealth) {
                    const heartX = 15 + (player.health * 24) + 12;
                    const heartY = 15 + 12;
                    player.health++; 
                    spawnHudParticles(heartX, heartY, '255, 255, 0');
                    triggerBackgroundFlash({ r: 13, g: 50, b: 46 }, 20);
                } 
                break;
            case 'star': 
            case 'boots': 
            case 'bolt': 
                startPowerUp(type, type === 'star' ? 15*60 : type === 'boots' ? 30*60 : 25*60); 
                triggerBackgroundFlash({ r: 30, g: 50, b: 80 }, 20);
                break;
        }
    }
    
    function takeDamage(amount) {
        if (player.isImmune || player.isDying) return;
        
        let finalDamage = amount;
        if (amount === 3 && player.health <= 3) { finalDamage = player.health - 1; }

        const heartX = 15 + ((player.health - 1) * 24) + 12;
        const heartY = 15 + 12;

        player.health -= finalDamage;
        spawnHudParticles(heartX, heartY, '255, 50, 50');
        camera.shakeDuration = 20;
        camera.shakeMagnitude = 8;
        triggerBackgroundFlash({ r: 0, g: 0, b: 0 }, 15);

        if (player.health <= 0) {
            player.health = 0;
            startDeathSequence();
        } else {
            player.isImmune = true;
            setTimeout(() => {
                if (player.powerUp !== 'star') { player.isImmune = false; }
            }, 2000);
        }
    }

    function startPowerUp(type, duration) {
        endPowerUp();
        player.powerUp = type;
        player.powerUpTimer = duration;
        switch(type) {
            case 'star': player.isImmune = true; break;
            case 'boots': player.canDoubleJump = true; break;
            case 'bolt': player.speedMultiplier = 1.5; break;
        }
    }

    function endPowerUp() {
        if (!player.powerUp) return;
        switch(player.powerUp) {
            case 'star': player.isImmune = false; break;
            case 'boots': player.canDoubleJump = false; break;
            case 'bolt': player.speedMultiplier = 1; break;
        }
        player.powerUp = null;
        player.powerUpTimer = 0;
    }

    function startDeathSequence() {
        if (player.isDying) return;
        player.isDying = true;
        player.vy = JUMP_FORCE * 0.8;
        const gravestoneX = player.x;
        const gravestoneY = player.y + player.height - 20;
        gravestones.push({ x: gravestoneX, y: gravestoneY, facingRight: player.facingRight });
        spawnHudParticles(gravestoneX, gravestoneY, '255, 50, 50');
        targetBgColor = { r: 0, g: 0, b: 0 };
    }

    function showGameOverScreen() {
        if (!gameRunning && !player.isDying) return;
        gameRunning = false;
        player.isDying = false;
        cancelAnimationFrame(gameLoopId);
        finalScoreDisplay.textContent = `Sua pontua√ß√£o final: ${player.xp} üîÜ`;
        gameOverScreen.style.display = 'flex';
    }

    // --- DRAW LOGIC ---
    function draw() {
        const bgR = Math.round(currentBgColor.r);
        const bgG = Math.round(currentBgColor.g);
        const bgB = Math.round(currentBgColor.b);
        canvas.style.backgroundColor = `rgb(${bgR}, ${bgG}, ${bgB})`;
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.save();
        
        let shakeX = 0;
        let shakeY = 0;
        if (camera.shakeDuration > 0) {
            shakeX = (Math.random() - 0.5) * camera.shakeMagnitude;
            shakeY = (Math.random() - 0.5) * camera.shakeMagnitude;
            camera.shakeDuration--;
        }

        ctx.translate(canvas.width / 2, canvas.height / 2);
        ctx.scale(camera.zoom, camera.zoom);
        ctx.translate(-camera.x - shakeX, -camera.y - shakeY);

        // Draw platforms
        ctx.fillStyle = '#4a4a4a';
        platforms.forEach(p => { ctx.fillRect(p.x, p.y, p.width, p.height); });
        
        // Draw world particles
        particles.forEach(p => {
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x, p.y, p.size, p.size);
        });

        ctx.fillStyle = '#FFFFFF';

        // Draw gravestones
        ctx.font = '40px sans-serif';
        gravestones.forEach(g => {
            ctx.save();
            if (g.facingRight) {
                ctx.translate(g.x + 40, g.y);
                ctx.scale(-1, 1);
                ctx.fillText('ü¶Ω', 0, 0);
            } else {
                ctx.fillText('ü¶Ω', g.x, g.y);
            }
            ctx.restore();
        });

        // Draw items
        ctx.font = '30px sans-serif';
        items.forEach(item => {
            let emoji = '';
            switch(item.type) {
                case 'xp': emoji = 'üîÜ'; break;
                case 'health': emoji = 'üíä'; break;
                case 'star': emoji = '‚≠ê'; break;
                case 'boots': emoji = 'üë£'; break;
                case 'bolt': emoji = '‚ö°'; break;
            }
            ctx.fillText(emoji, item.x, item.y + item.height);
        });
        
        // Draw enemies
        enemies.forEach(enemy => {
            ctx.save();
            ctx.font = '40px sans-serif';
            let emoji = '';
            switch(enemy.type) {
                case 'ghost': emoji = 'üëª'; break;
                case 'flyer': emoji = 'üëæ'; break;
                case 'dragon': 
                    emoji = 'üêâ';
                    if (enemy.facingDirection > 0) {
                        ctx.translate(enemy.x + enemy.width, enemy.y);
                        ctx.scale(-1, 1);
                        ctx.fillText(emoji, 0, enemy.height);
                    } else {
                        ctx.fillText(emoji, enemy.x, enemy.y + enemy.height);
                    }
                    break;
            }
            
            if (enemy.type !== 'dragon') {
                ctx.fillText(emoji, enemy.x, enemy.y + enemy.height);
            }

            if (enemy.isWarning) {
                ctx.font = '20px sans-serif';
                let warningX = enemy.facingDirection > 0 ? enemy.x + enemy.width : enemy.x - 25;
                if (enemy.type === 'dragon' && enemy.facingDirection > 0) {
                    warningX = -25;
                }
                ctx.fillText('‚ô®Ô∏è', warningX, enemy.y + enemy.height - 15);
            }
            ctx.restore();
        });
        
        // Draw projectiles
        ctx.font = '30px sans-serif';
        ctx.fillStyle = 'orange';
        projectiles.forEach(p => { ctx.fillText('üî•', p.x, p.y + p.height); });

        // Draw player
        ctx.save();
        if (player.isDying) {
            ctx.font = '50px sans-serif';
            ctx.translate(player.x + player.width / 2, player.y + player.height / 2);
            ctx.rotate(player.rotation * Math.PI / 180);
            ctx.fillText('ü§∏', -player.width / 2, player.height / 2);
        } else {
            if (player.isImmune) {
                ctx.globalAlpha = (Math.sin(Date.now() / 50) + 1) / 2 * 0.5 + 0.5;
                if (player.powerUp === 'star') { ctx.shadowColor = 'yellow'; ctx.shadowBlur = 20; }
            }
            
            ctx.font = '50px sans-serif';
            if (player.facingRight) {
                ctx.translate(player.x + player.width, player.y);
                ctx.scale(-1, 1);
                ctx.fillText('üë®‚Äçü¶º', 0, player.height);
            } else {
                ctx.fillText('üë®‚Äçü¶º', player.x, player.y + player.height);
            }
        }
        ctx.restore();

        ctx.restore();

        // Draw HUD particles on top of everything
        hudParticles.forEach(p => {
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x, p.y, p.size, p.size);
        });
    }
    
    function drawHUD() {
        healthDisplay.innerHTML = '‚ù§Ô∏è'.repeat(player.health);
        xpTextDisplay.textContent = player.xp;

        let powerUpHTML = '';
        if (player.powerUp) {
            switch(player.powerUp) {
                case 'star': powerUpHTML = '‚≠ê'; break;
                case 'boots': powerUpHTML = 'üë£'; break;
                case 'bolt': powerUpHTML = '‚ö°'; break;
            }
        }
        powerUpDisplay.innerHTML = powerUpHTML;
        
        if (player.powerUpTimer > 0 && player.powerUpTimer < 300) {
            powerUpDisplay.classList.toggle('blinking', Math.floor(player.powerUpTimer / 30) % 2 === 0);
        } else {
            powerUpDisplay.classList.remove('blinking');
        }
    }

    // --- MAIN GAME LOOP ---
    function gameLoop() {
        if (!gameRunning && !player.isDying) {
             cancelAnimationFrame(gameLoopId);
             return;
        }
        update();
        draw();
        drawHUD();
        gameLoopId = requestAnimationFrame(gameLoop);
    }

    // --- EVENT LISTENERS ---
    window.addEventListener('keydown', e => {
        if (!gameRunning) return;
        switch (e.code) {
            case 'KeyA': case 'ArrowLeft': keys.left = true; break;
            case 'KeyD': case 'ArrowRight': keys.right = true; break;
            case 'Space':
                if (player.coyoteTimeCounter > 0) {
                    player.vy = JUMP_FORCE;
                    player.onGround = false;
                    player.coyoteTimeCounter = 0;
                    spawnJumpParticles(player.x + player.width / 2, player.y + player.height);
                } else if (player.canDoubleJump && !player.doubleJumpUsed) {
                    player.vy = JUMP_FORCE * 0.9;
                    player.doubleJumpUsed = true;
                    spawnJumpParticles(player.x + player.width / 2, player.y + player.height);
                } else {
                    player.jumpBufferCounter = JUMP_BUFFER_FRAMES;
                }
                break;
            case 'KeyS': case 'ArrowDown':
                if (player.onGround) {
                    player.y += 5;
                    player.onGround = false;
                }
                break;
        }
    });

    window.addEventListener('keyup', e => {
        if (!gameRunning) return;
        switch (e.code) {
            case 'KeyA': case 'ArrowLeft': keys.left = false; break;
            case 'KeyD': case 'ArrowRight': keys.right = false; break;
        }
    });

    startButton.addEventListener('click', () => {
        startScreen.style.display = 'none';
        init();
        gameRunning = true;
        gameLoop();
    });



    restartButton.addEventListener('click', () => {
        gameOverScreen.style.display = 'none';
        init();
        gameRunning = true;
        gameLoop();
    });

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

</script>
</body>
</html>
